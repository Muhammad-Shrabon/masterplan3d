<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Master Plan Layout</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Load OrbitControls (Requires THREE global object) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        /* Set the canvas to fill the entire viewport area */
        #container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #f0f0f0;
            /* Light background for contrast */
        }

        /* Hide scrollbars */
        body {
            overflow: hidden;
            font-family: 'Inter', sans-serif;
        }
    </style>
</head>

<body class="font-sans bg-gray-100">

    <!-- Three.js Container -->
    <div id="container"></div>

    <!-- Loading and Instruction Overlay -->
    <div id="loading-overlay"
        class="absolute inset-0 bg-gray-900 bg-opacity-90 flex flex-col items-center justify-center z-50 transition-opacity duration-500">
        <div class="text-white text-center p-8 rounded-lg">
            <svg class="animate-spin h-8 w-8 text-white mx-auto mb-4" xmlns="http://www.w3.org/2000/svg" fill="none"
                viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor"
                    d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">
                </path>
            </svg>
            <h1 class="text-3xl font-bold mb-4">Master Plan 3D Preview</h1>
            <p class="text-xl">Initializing 3D environment...</p>
        </div>
    </div>

    <!-- Instructions -->
    <div
        class="absolute top-4 left-4 p-4 bg-white/70 backdrop-blur-sm rounded-xl shadow-lg border border-gray-200 z-10 w-64">
        <h2 class="font-semibold text-lg text-gray-800 mb-2">Controls:Â </h2>
        <ul class="list-disc list-inside text-sm text-gray-700 space-y-1">
            <li><span class="font-medium">Left Click:</span> Select House</li>
            <li><span class="font-medium">Left Drag:</span> Rotate (Orbit)</li>
            <li><span class="font-medium">Right Drag:</span> Pan (Move)</li>
            <li><span class="font-medium">Scroll:</span> Zoom In / Out</li>
        </ul>
        <p class="mt-3 text-xs text-gray-600">This is an abstract 3D model representing the zoning of the master plan
            (Residential, River, Green Space, Roads).</p>
    </div>

    <!-- House Information Popup (Right Side) -->
    <div id="house-popup"
        class="absolute top-4 right-4 w-80 bg-white/90 backdrop-blur-md rounded-2xl shadow-2xl border border-gray-100 z-20 transform translate-x-full transition-transform duration-300 ease-in-out p-6 hidden">
        <div class="flex justify-between items-start mb-4">
            <div>
                <h2 class="text-2xl font-bold text-gray-800" id="popup-title">House Details</h2>
                <p class="text-sm text-gray-500" id="popup-id">ID: #---</p>
            </div>
            <button id="close-popup"
                class="bg-gray-100 hover:bg-gray-200 text-gray-600 rounded-full p-2 transition-colors">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd"
                        d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z"
                        clip-rule="evenodd" />
                </svg>
            </button>
        </div>

        <div class="space-y-4">
            <div class="bg-blue-50 p-4 rounded-xl border border-blue-100">
                <p class="text-xs font-semibold text-blue-600 uppercase tracking-wide mb-1">Status</p>
                <p class="text-lg font-medium text-blue-900" id="popup-status">Available</p>
            </div>

            <div class="grid grid-cols-2 gap-3">
                <div class="bg-gray-50 p-3 rounded-lg">
                    <p class="text-xs text-gray-500 mb-1">Area</p>
                    <p class="font-semibold text-gray-800">2,400 sqft</p>
                </div>
                <div class="bg-gray-50 p-3 rounded-lg">
                    <p class="text-xs text-gray-500 mb-1">Price</p>
                    <p class="font-semibold text-gray-800">$450,000</p>
                </div>
            </div>

            <div>
                <p class="text-sm text-gray-600 leading-relaxed">
                    Premium residential unit with view of the community park. Close to main highway entrance.
                </p>
            </div>

            <button
                class="w-full bg-blue-600 hover:bg-blue-700 text-white font-medium py-3 rounded-xl transition-colors shadow-lg shadow-blue-600/30 mt-2">
                Contact Agent
            </button>
        </div>
    </div>

    <script>
        // Global Three.js variables
        let scene, camera, renderer, controls;
        let mapGroup = new THREE.Group(); // Group to hold all map elements for easier manipulation

        // Raycaster for interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let selectedHouse = null;
        const SELECTED_COLOR = 0xFFC107; // Amber/Gold color for selection
        let originalHouseColor = null;

        // Global variables for road coordinates, needed for block calculation
        const ROAD_WIDTH = 20;
        let longitudinalX = [];
        let transverseZ = [];

        // --- Configuration: Increased Map Size ---
        const MAP_WIDTH = 2500; // Doubled width for a larger area
        const MAP_LENGTH = 2800; // Doubled length for a larger area

        /**
         * Initializes the Three.js scene, camera, renderer, and controls.
         */
        function init() {
            // Use try/catch to log errors during initialization, which helps debugging in the inspect panel.
            try {
                const container = document.getElementById('container');

                // 1. Scene Setup
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x01C3F5); // Lighter green sky/horizon

                // 2. Camera Setup
                camera = new THREE.PerspectiveCamera(
                    45,
                    window.innerWidth / window.innerHeight,
                    1,
                    50000
                );
                // Position the camera high up, looking down onto the new center of the map
                camera.position.set(MAP_WIDTH / 2, 1200, MAP_LENGTH / 2);
                camera.lookAt(MAP_WIDTH / 2, 0, MAP_LENGTH / 2);

                // 3. Renderer Setup
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.shadowMap.enabled = true; // Enable shadow maps
                container.appendChild(renderer.domElement);

                // Add the map group to the scene
                scene.add(mapGroup);

                // 4. Controls Setup (OrbitControls)
                // Check if controls are available (often a failure point if the CDN script didn't load)
                if (typeof THREE.OrbitControls === 'undefined') {
                    console.error("Error: THREE.OrbitControls not loaded. Check the CDN script link in the head.");
                    return; // Stop initialization if controls are missing
                }
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.target.set(MAP_WIDTH / 2, 0, MAP_LENGTH / 2); // Center controls on the map
                controls.maxPolarAngle = Math.PI / 2.5; // Prevent camera from going under the ground
                controls.enableDamping = true; // For a smoother feel
                controls.dampingFactor = 0.05;

                // 5. Lighting
                addLighting();

                // 6. Create Map Elements
                createGroundAndBoundary();
                createRiver();

                createGridRoads(); // Must run first to populate road arrays
                createAmenitiesAndRoads(); // Uses road positions for placement, placed before blocks to reserve space
                populateGridBlocks(); // Fills the blocks around amenities and grid roads
                createResidentialBlocks(); // Curved strip is still separate

                // 7. Event Listeners
                // 7. Event Listeners
                window.addEventListener('resize', onWindowResize);
                window.addEventListener('pointerdown', onPointerDown); // Use pointerdown for better mobile/desktop handling

                // Close button listener
                document.getElementById('close-popup').addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent triggering map click
                    deselectHouse();
                });

                // Start the animation loop
                animate();

            } catch (error) {
                console.error("FATAL ERROR during Three.js initialization:", error);
                document.getElementById('loading-overlay').innerHTML = `
                    <div class="text-white text-center p-8 rounded-xl bg-red-700">
                        <h1 class="text-3xl font-bold mb-4">Initialization Error</h1>
                        <p class="text-lg">The 3D scene failed to load. Please check the browser console for details to debug the issue.</p>
                        <p class="text-sm mt-4 italic">Error: ${error.message}</p>
                    </div>
                `;
            }
        }

        /**
         * Adds lighting to the scene.
         */
        function addLighting() {
            // Ambient light for general scene illumination
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            // Directional light (Simulating the sun)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(500, 1500, 500); // Position high and slightly offset
            directionalLight.castShadow = true;

            // Configure shadow properties
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            const d = 1000;
            directionalLight.shadow.camera.left = -d;
            directionalLight.shadow.camera.right = d;
            directionalLight.shadow.camera.top = d;
            directionalLight.shadow.camera.bottom = -d;
            directionalLight.shadow.camera.near = 100;
            directionalLight.shadow.camera.far = 3000;

            scene.add(directionalLight);
        }

        /**
         * Creates the main ground plane (green area) and a base boundary.
         */
        function createGroundAndBoundary() {
            // Base plane (Main Green Area - now much larger)
            const groundGeometry = new THREE.PlaneGeometry(MAP_WIDTH + 600, MAP_LENGTH + 600);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x558B2F }); // Darker green for vegetation
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2; // Rotate to lie flat
            ground.position.set(MAP_WIDTH / 2, -1, MAP_LENGTH / 2);
            ground.receiveShadow = true;
            mapGroup.add(ground);

            // Central Development Land (lighter green - also larger)
            const landGeometry = new THREE.PlaneGeometry(MAP_WIDTH + 200, MAP_LENGTH + 200);
            const landMaterial = new THREE.MeshLambertMaterial({ color: 0x8BC34A }); // Lighter green for development land
            const land = new THREE.Mesh(landGeometry, landMaterial);
            land.rotation.x = -Math.PI / 2;
            land.position.set(MAP_WIDTH / 2, 0, MAP_LENGTH / 2);
            land.receiveShadow = true;
            mapGroup.add(land);
        }

        /**
         * Creates the main river path, now located outside the enlarged primary land area.
         */
        function createRiver() {
            // Increased offset to keep the river outside the new, larger MAP_LENGTH boundary (3000)
            const Z_OFFSET = 600;

            const riverPoints2D = [
                // X coordinates are scaled, Z coordinates are relative to the new map length
                new THREE.Vector2(-200, MAP_LENGTH + 50 + Z_OFFSET),
                new THREE.Vector2(400, MAP_LENGTH - 100 + Z_OFFSET),
                new THREE.Vector2(800, MAP_LENGTH + 50 + Z_OFFSET), // New center X
                new THREE.Vector2(1200, MAP_LENGTH - 50 + Z_OFFSET),
                new THREE.Vector2(MAP_WIDTH + 200, MAP_LENGTH + 50 + Z_OFFSET),
            ];

            // Convert 2D points to 3D points (y is up). 
            const riverPoints3D = riverPoints2D.map(p => new THREE.Vector3(p.x, -0.5, p.y));

            // Create a smooth curve using CatmullRomCurve3
            const curve = new THREE.CatmullRomCurve3(riverPoints3D, false, 'centripetal');

            const riverRadius = 80; // Slightly wider river
            const tubularSegments = 200;
            const radialSegments = 4;

            // Create TubeGeometry along the curve
            const riverGeometry = new THREE.TubeGeometry(
                curve,
                tubularSegments,
                riverRadius,
                radialSegments,
                false
            );

            // Material for deeper water color and higher opacity
            const riverMaterial = new THREE.MeshLambertMaterial({
                color: 0x0056a0, // Darker blue water
                transparent: true,
                opacity: 0.85
            });

            const riverMesh = new THREE.Mesh(riverGeometry, riverMaterial);
            riverMesh.receiveShadow = true;
            mapGroup.add(riverMesh);
        }

        /**
         * Creates a simple low-poly tree.
         */
        function createTree() {
            const treeGroup = new THREE.Group();

            // Trunk
            const trunkGeometry = new THREE.CylinderGeometry(1.5, 1.5, 6, 6);
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8D6E63 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 3; // Half height
            trunk.castShadow = true;
            treeGroup.add(trunk);

            // Foliage (two cones for better look)
            const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x388E3C });

            const lowerCone = new THREE.Mesh(new THREE.ConeGeometry(5, 8, 8), leavesMaterial);
            lowerCone.position.y = 8;
            lowerCone.castShadow = true;
            treeGroup.add(lowerCone);

            const upperCone = new THREE.Mesh(new THREE.ConeGeometry(4, 7, 8), leavesMaterial);
            upperCone.position.y = 12;
            upperCone.castShadow = true;
            treeGroup.add(upperCone);

            return treeGroup;
        }

        /**
         * Creates a single house model with plot border and tree.
         */
        function createHouseModel(width, length, id) {
            const houseGroup = new THREE.Group();
            const bodyHeight = 8;

            // Generate Random Status
            // 40% Available, 30% Sold, 20% Reserved, 10% Booked
            const rand = Math.random();
            let status = 'Available';
            let statusColor = 0x4CAF50; // Green

            if (rand > 0.9) {
                status = 'Booked';
                statusColor = 0x2196F3; // Blue
            } else if (rand > 0.7) {
                status = 'Reserved';
                statusColor = 0xFF9800; // Orange
            } else if (rand > 0.4) {
                status = 'Sold';
                statusColor = 0xF44336; // Red
            }

            // Store status in user data for selection logic
            houseGroup.userData.isHouse = true;
            houseGroup.userData.id = id;
            houseGroup.userData.status = status;
            houseGroup.userData.statusColor = statusColor;



            // --- Plot Boundary (Dotted Line) ---
            // Increased plot buffer for "Larger Land Area"
            const plotWidth = width + 25;
            const plotLength = length + 35;

            // Create a rectangle shape for the plot
            const plotGeometry = new THREE.EdgesGeometry(new THREE.PlaneGeometry(plotWidth, plotLength));
            const plotMaterial = new THREE.LineDashedMaterial({
                color: 0xaaaaaa,
                dashSize: 4,  // Bigger dashes
                gapSize: 3,
                opacity: 0.6,
                transparent: true
            });

            const plotLines = new THREE.LineSegments(plotGeometry, plotMaterial);
            plotLines.rotation.x = -Math.PI / 2; // Lie flat on ground
            plotLines.position.y = 0.2;
            plotLines.computeLineDistances();
            houseGroup.add(plotLines);

            // --- House Body (White/Cream) ---
            const bodyGeometry = new THREE.BoxGeometry(width, bodyHeight, length);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0xf5f5f5 });
            const houseBody = new THREE.Mesh(bodyGeometry, bodyMaterial);
            houseBody.position.y = bodyHeight / 2;
            houseBody.castShadow = true;

            // Mark as house part and store parent reference if needed
            houseBody.userData.isHousePart = true;
            houseBody.userData.originalColor = bodyMaterial.color.getHex();

            houseGroup.add(houseBody);
            // --- Pitched Roof (Gable Style) ---
            const roofHeight = 6;
            const roofWidth = width * 1.2;
            const roofLength = length * 1.1;

            const shape = new THREE.Shape();
            shape.moveTo(0, 0);
            shape.lineTo(roofWidth / 2, roofHeight);
            shape.lineTo(roofWidth, 0);
            shape.lineTo(0, 0);

            const extrudeSettings = {
                steps: 1,
                depth: roofLength,
                bevelEnabled: false
            };

            const gableGeometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            gableGeometry.translate(-roofWidth / 2, 0, -roofLength / 2);

            const roofMaterial = new THREE.MeshLambertMaterial({ color: 0x8e554a });
            const gableRoof = new THREE.Mesh(gableGeometry, roofMaterial);
            gableRoof.position.y = bodyHeight;
            gableRoof.castShadow = true;

            // Interaction Tags
            gableRoof.userData.isHousePart = true;
            gableRoof.userData.originalColor = roofMaterial.color.getHex();

            houseGroup.add(gableRoof);

            // --- Dormer (Small extension) ---
            const dormerWidth = roofWidth * 0.4;
            const dormerHeight = roofHeight * 0.6;
            const dormerLength = roofWidth * 0.5;

            const dormerShape = new THREE.Shape();
            dormerShape.moveTo(0, 0);
            dormerShape.lineTo(dormerWidth / 2, dormerHeight);
            dormerShape.lineTo(dormerWidth, 0);
            dormerShape.lineTo(0, 0);

            const dormerGeo = new THREE.ExtrudeGeometry(dormerShape, {
                steps: 1,
                depth: dormerLength,
                bevelEnabled: false
            });
            dormerGeo.translate(-dormerWidth / 2, 0, 0);

            const dormer = new THREE.Mesh(dormerGeo, roofMaterial);
            dormer.rotation.y = Math.PI / 2;
            dormer.position.set(roofWidth / 3, bodyHeight + 1.5, 0);

            // Interaction Tags
            dormer.userData.isHousePart = true;
            dormer.userData.originalColor = roofMaterial.color.getHex();

            houseGroup.add(dormer);

            // Window on Dormer
            const winGeo = new THREE.PlaneGeometry(dormerWidth * 0.4, dormerHeight * 0.4);
            const winMat = new THREE.MeshLambertMaterial({ color: 0x87CEEB });
            const windowMesh = new THREE.Mesh(winGeo, winMat);
            windowMesh.rotation.y = Math.PI / 2;
            windowMesh.position.set(roofWidth / 3 + dormerLength + 0.1, bodyHeight + 2.5, 0);
            houseGroup.add(windowMesh);

            // --- Create Door Texture with Number ---
            // Helper function logic inline or separate? Let's keep it clean.
            // Since we didn't add the helper function globally yet, let's just generate the canvas here.

            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            // Draw Door Background
            ctx.fillStyle = '#8D6E63'; // Wood color
            ctx.fillRect(0, 0, 128, 256);

            // Draw Panel details
            ctx.strokeStyle = '#5D4037';
            ctx.lineWidth = 5;
            ctx.strokeRect(10, 10, 108, 236);

            // Draw Number
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 60px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(id, 64, 80); // Top half

            const doorTexture = new THREE.CanvasTexture(canvas);

            // Simplified door/window proxies
            const doorHeight = bodyHeight * 0.8;
            const doorGeometry = new THREE.BoxGeometry(width * 0.25, doorHeight, 0.1);
            const doorMaterial = new THREE.MeshLambertMaterial({ map: doorTexture });
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(0, doorHeight / 2, length / 2 + 0.05);
            houseGroup.add(door);

            // --- Add Tree ---
            const tree = createTree();
            // Position tree in the corner of the plot
            // Moved to "Opposite" side (Front instead of Back)
            const cornerX = (plotWidth / 2) - 8;
            const cornerZ = (plotLength / 2) - 8; // Front corner (Positive Z)

            // Place on left or right side randomly
            const side = Math.random() > 0.5 ? 1 : -1;
            tree.position.set(side * cornerX, 0, cornerZ);

            houseGroup.add(tree);

            return houseGroup;
        }


        /**
         * Creates the residential strips following a curved layout.
         */
        /**
         * Creates the residential strips following a curved layout with clustered blocks and a river.
         */
        function createResidentialBlocks() {
            // Updated Material for the "Green Spine" (previously road)
            const greenCentralMaterial = new THREE.MeshLambertMaterial({ color: 0x8BC34A }); // Same as development land
            // Material for the Road Divider
            const roadDividerMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });

            const HOUSE_WIDTH = 40;
            const HOUSE_LENGTH = 70;
            // HOUSE_SPACING is now calculated automatically

            // Block Configuration: House counts per block
            const blockCounts = [20, 26, 36, 12, 30];
            const totalHousesInBlocks = blockCounts.reduce((a, b) => a + b, 0);
            // Separation between the two house strips
            const stripSeparation = HOUSE_LENGTH * 1.5;

            // --- Curve Definition Change ---
            // Target: 90-Degree "L" Shape
            // Path: Top-Left -> Bottom-Left (Turn) -> Bottom-Right

            const startZ = MAP_LENGTH * 0.25;
            const endZ = MAP_LENGTH * 0.85;

            const residentialPoints2D = [
                new THREE.Vector2(200, startZ),                         // Start: Top-Left
                new THREE.Vector2(200, endZ - 400),                     // Vertical Leg (Down to corner)
                new THREE.Vector2(600, endZ),                           // Horizontal Leg (After turn)
                new THREE.Vector2(MAP_WIDTH - 100, endZ),               // End: Bottom-Right
            ];

            const residentialCurve = new THREE.CatmullRomCurve3(
                residentialPoints2D.map(p => new THREE.Vector3(p.x, 0, p.y)),
                false, 'centripetal'
            );

            // --- Auto-Calculate Spacing ---
            const curveLength = residentialCurve.getLength();
            const gapSizeMultiplier = 4; // Gap = N * Spacing

            const totalPairs = Math.ceil(totalHousesInBlocks / 2);
            const numGaps = blockCounts.length - 1;
            const HOUSE_SPACING = curveLength / (totalPairs + (numGaps * gapSizeMultiplier));

            console.log("Auto-calculated Spacing:", HOUSE_SPACING);

            // --- Control Points for Identity ---
            // Visual markers for Start and End of the curve
            const markerGeometry = new THREE.SphereGeometry(30, 32, 32);

            // Start Point (Green)
            const startPoint = residentialCurve.getPoint(0);
            const startMarker = new THREE.Mesh(markerGeometry, new THREE.MeshLambertMaterial({ color: 0x00FF00 }));
            startMarker.position.copy(startPoint);
            startMarker.position.y = 15;
            mapGroup.add(startMarker);

            // End Point (Red)
            const endPoint = residentialCurve.getPoint(1);
            const endMarker = new THREE.Mesh(markerGeometry, new THREE.MeshLambertMaterial({ color: 0xFF0000 }));
            endMarker.position.copy(endPoint);
            endMarker.position.y = 15;
            mapGroup.add(endMarker);


            // --- Create Parallel Road (formerly River) ---
            const parallelRoadPoints = [];
            const roadOffsetDistance = stripSeparation + 180; // Distance from center spine to parallel road
            const divisions = 250;

            for (let i = 0; i <= divisions; i++) {
                const t = i / divisions;
                const point = residentialCurve.getPoint(t);
                const tangent = residentialCurve.getTangent(t).normalize();
                const normal = new THREE.Vector3(-tangent.z, 0, tangent.x);

                // Offset to "Outer" side relative to the curve direction
                const roadPos = point.clone().add(normal.clone().multiplyScalar(roadOffsetDistance));
                parallelRoadPoints.push(roadPos);
            }

            const parallelRoadCurve = new THREE.CatmullRomCurve3(parallelRoadPoints);
            const parallelRoadGeometry = new THREE.TubeGeometry(parallelRoadCurve, 250, 70, 8, false); // Width 70 (Radius 70)

            // "Road Style": Grey color, flat appearance
            const parallelRoadMaterial = new THREE.MeshLambertMaterial({
                color: 0x555555, // Grey road
            });

            const parallelRoadMesh = new THREE.Mesh(parallelRoadGeometry, parallelRoadMaterial);
            parallelRoadMesh.position.y = 0.5; // Just above ground
            // Flatten to look like a road
            parallelRoadMesh.scale.set(1, 0.05, 1);

            mapGroup.add(parallelRoadMesh);


            // --- Place Houses in Blocks ---

            let currentT = 0;
            const advanceT = (distance) => distance / curveLength;

            let houseCounter = 1;

            blockCounts.forEach((count, blockIndex) => {
                const pairs = Math.ceil(count / 2); // Houses per side for this block

                for (let i = 0; i < pairs; i++) {
                    if (currentT >= 1) break; // formatting safety

                    const point = residentialCurve.getPoint(currentT);
                    const tangent = residentialCurve.getTangent(currentT).normalize();
                    const normal = new THREE.Vector3(-tangent.z, 0, tangent.x);

                    // --- 1. Inner Strip ---
                    const innerOffset = normal.clone().multiplyScalar(-stripSeparation / 2);
                    const innerPosition = point.clone().add(innerOffset);

                    const id1 = `RiverHouse-${houseCounter.toString().padStart(2, '0')}`;
                    const house1 = createHouseModel(HOUSE_WIDTH, HOUSE_LENGTH, id1);
                    house1.userData.type = 'houseNearRiver'; // Update identity
                    houseCounter++;

                    house1.rotation.y = Math.atan2(normal.x, normal.z);
                    house1.position.copy(innerPosition);
                    mapGroup.add(house1);

                    // Place second house of pair only if count isn't odd (checked naturally by total count loop if we did it that way, but here we do pairs)
                    // If total count is odd, the last pair might just have one house?
                    // Let's assume full pairs for simplicity or handle the remainder.
                    // The user gave even numbers mostly (20, 26, 36, 12, 30), so pairs are fine.

                    // --- 2. Outer Strip ---
                    const outerOffset = normal.clone().multiplyScalar(stripSeparation / 2);
                    const outerPosition = point.clone().add(outerOffset);

                    const id2 = `RiverHouse-${houseCounter.toString().padStart(2, '0')}`;
                    const house2 = createHouseModel(HOUSE_WIDTH, HOUSE_LENGTH, id2);
                    house2.userData.type = 'houseNearRiver'; // Update identity
                    houseCounter++;

                    house2.rotation.y = Math.atan2(normal.x, normal.z);
                    house2.position.copy(outerPosition);
                    mapGroup.add(house2);

                    // --- 3. Green Land Spine ---
                    const spineWidth = stripSeparation * 1.1;
                    const spineLength = HOUSE_SPACING * 1.05; // Slightly overlap

                    const spineGeo = new THREE.BoxGeometry(spineWidth, 0.5, spineLength);
                    const spine = new THREE.Mesh(spineGeo, greenCentralMaterial);

                    spine.position.copy(point);
                    spine.position.y = 0.1;
                    spine.rotation.y = Math.atan2(tangent.x, tangent.z);

                    mapGroup.add(spine);

                    // Advance T for next house
                    currentT += advanceT(HOUSE_SPACING);
                }

                // --- Add Road Divider after the block ---
                // Only if it's not the very last block
                if (blockIndex < blockCounts.length - 1) {
                    // Gap for the road
                    currentT += advanceT(HOUSE_SPACING * (gapSizeMultiplier * 0.2));

                    if (currentT < 1) {
                        const point = residentialCurve.getPoint(currentT);
                        const tangent = residentialCurve.getTangent(currentT).normalize();

                        // Create a road segment crossing the path
                        // Width should be enough to look like a road (approx 30-40)
                        // Length (across the path) should cover the strips + river separation roughly?
                        // User said "divided with road in 5 block". Usually means a cross street.

                        const roadWidth = 40;
                        const roadLengthAcross = stripSeparation * 2.5;

                        const dividerGeo = new THREE.BoxGeometry(roadLengthAcross, 0.2, roadWidth);
                        const divider = new THREE.Mesh(dividerGeo, roadDividerMaterial);

                        divider.position.copy(point);
                        divider.position.y = 0.15; // Slightly higher to be visible over grass
                        divider.rotation.y = Math.atan2(tangent.x, tangent.z);

                        mapGroup.add(divider);
                    }

                    // Remaining Gap
                    currentT += advanceT(HOUSE_SPACING * (gapSizeMultiplier * 0.8));
                }
            });
        }

        /**
         * Creates a grid of roads across the main map area and stores their coordinates.
         */
        // function createGridRoads() {
        //     const roadMaterial = new THREE.MeshLambertMaterial({ color: 0x212121 });

        //     // Longitudinal Roads (Vertical - X=constant, Z=variable)
        //     const longRoads = 5;
        //     const longSpacing = MAP_WIDTH / (longRoads + 1);
        //     longitudinalX = []; // Clear array before population
        //     for (let i = 1; i <= longRoads; i++) {
        //         const x = longSpacing * i;
        //         longitudinalX.push(x);
        //         const roadGeometry = new THREE.BoxGeometry(ROAD_WIDTH, 0.1, MAP_LENGTH);
        //         const road = new THREE.Mesh(roadGeometry, roadMaterial);
        //         road.position.set(x, 0.1, MAP_LENGTH / 2);
        //         road.receiveShadow = true;
        //         mapGroup.add(road);
        //     }

        //     // Transverse Roads (Horizontal - Z=constant, X=variable)
        //     const transRoads = 6;
        //     const Z_START = 500;
        //     const Z_END = MAP_LENGTH * 0.6; // 2800 * 0.6 = 1680
        //     const transLength = Z_END - Z_START;
        //     const transSpacing = transLength / (transRoads + 1);
        //     transverseZ = []; // Clear array before population

        //     for (let i = 1; i <= transRoads; i++) {
        //         const z = Z_START + transSpacing * i;
        //         transverseZ.push(z);
        //         const roadGeometry = new THREE.BoxGeometry(MAP_WIDTH, 0.1, ROAD_WIDTH);
        //         const road = new THREE.Mesh(roadGeometry, roadMaterial);
        //         road.position.set(MAP_WIDTH / 2, 0.1, z);
        //         road.receiveShadow = true;
        //         mapGroup.add(road);
        //     }
        // }

        function createGridRoads() {
            // Define a single material for ALL roads (straight and curved).
            // This material uses the dark grey color (0x212121) and reacts to lighting.
            const roadMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });

            const CURVE_START_Z = MAP_LENGTH * 0.8;

            // --- Longitudinal Roads (Vertical - X=constant, Z=variable) ---
            const longRoads = 5;
            const longSpacing = MAP_WIDTH / (longRoads + 1);
            longitudinalX = [];

            for (let i = 1; i <= longRoads; i++) {
                const x = longSpacing * i;
                longitudinalX.push(x);

                let road;

                if (i === 1) { // Apply the curve to the FIRST longitudinal road (i=1)
                    // Define points for the smooth curved path
                    const straightEnd = CURVE_START_Z;

                    const curvePoints = [
                        new THREE.Vector3(x, 0.1, 0),                        // Start
                        new THREE.Vector3(x, 0.1, straightEnd - 260),        // Control Point 1 (Straight run)
                        new THREE.Vector3(x, 0.1, straightEnd),              // Start of Curve
                        new THREE.Vector3(x + 100, 0.1, straightEnd + 20),  // Mid-Curve Control Point
                        new THREE.Vector3(x + 200, 0.1, straightEnd + 80)   // End Point (the 100 degree turn)
                    ];

                    const curve = new THREE.CatmullRomCurve3(curvePoints);

                    // Generate TubeGeometry along the curve
                    const roadGeometry = new THREE.TubeGeometry(
                        curve,                 // path
                        250,                   // segments (smoothness)
                        ROAD_WIDTH / -2,        // radius
                        60,                     // radial segments
                        false                  // not closed
                    );

                    // defined specific green material for curve road
                    const curvedRoadMaterial = new THREE.MeshLambertMaterial({ color: 0x848484 });

                    // Use the specific material
                    road = new THREE.Mesh(roadGeometry, curvedRoadMaterial);
                    road.receiveShadow = true; // Let the curved road receive shadows too
                    // Flatten the tube to look like a road, not a pipe
                    road.scale.set(1, 0.05, 1);

                } else {


                    // All other longitudinal roads remain straight boxes
                    const roadGeometry = new THREE.BoxGeometry(ROAD_WIDTH, 0.1, MAP_LENGTH);
                    // Use the single, shared roadMaterial
                    road = new THREE.Mesh(roadGeometry, roadMaterial);
                    road.position.set(x, 0.1, MAP_LENGTH / 2);
                    road.receiveShadow = true;
                }

                mapGroup.add(road);
            }

            // --- Transverse Roads (Horizontal - Z=constant, X=variable) ---
            const transRoads = 6;
            const Z_START = 500;
            const Z_END = MAP_LENGTH * 0.6;
            const transLength = Z_END - Z_START;
            const transSpacing = transLength / (transRoads + 1);
            transverseZ = [];

            for (let i = 1; i <= transRoads; i++) {
                const z = Z_START + transSpacing * i;
                transverseZ.push(z);
                const roadGeometry = new THREE.BoxGeometry(MAP_WIDTH, 0.1, ROAD_WIDTH);
                // Use the single, shared roadMaterial
                const road = new THREE.Mesh(roadGeometry, roadMaterial);
                road.position.set(MAP_WIDTH / 2, 0.1, z);
                road.receiveShadow = false;
                mapGroup.add(road);
            }
        }

        // function createGridRoads() {
        // const roadMaterial = new THREE.MeshLambertMaterial({ color: 0x212121 });
        // const CURVE_START_Z = MAP_LENGTH * 0.8; // Z-coordinate where the curve starts (e.g., 80% up the map)
        // const CURVE_LENGTH = MAP_LENGTH * 0.2; // Length over which the curve happens
        // const CURVE_RADIUS = 500; // Radius of the curve for the bend

        // // --- Longitudinal Roads (Vertical - X=constant, Z=variable) ---
        // const longRoads = 5;
        // const longSpacing = MAP_WIDTH / (longRoads + 1);
        // longitudinalX = []; // Clear array before population

        // for (let i = 1; i <= longRoads; i++) {
        //     const x = longSpacing * i;
        //     longitudinalX.push(x);

        //     let road;

        //     if (i === 1) { // Apply the curve to the FIRST longitudinal road (i=1)
        //         // 1. Define the points for the curved path
        //         const straightEnd = CURVE_START_Z;

        //         const startPoint = new THREE.Vector3(x, 0.1, 0);
        //         const straightEnd_Point = new THREE.Vector3(x, 0.1, straightEnd);

        //         // Define the center and angle for the arc
        //         const centerPoint = new THREE.Vector3(x, 0.1, straightEnd + CURVE_RADIUS);

        //         // Start of the curve (straight up)
        //         const curveStart = new THREE.Vector3(x, 0.1, straightEnd);
        //         // End of the curve (after 100 degrees rotation around the center)
        //         const angleInRadians = THREE.MathUtils.degToRad(120);

        //         // Calculate the end point of the 100 degree arc
        //         const endX = centerPoint.x + CURVE_RADIUS * Math.sin(angleInRadians);
        //         const endZ = centerPoint.z - CURVE_RADIUS * Math.cos(angleInRadians);
        //         const curveEnd = new THREE.Vector3(endX, 0.1, endZ);

        //         // 2. Create the path using a combination of straight lines and an arc
        //         const path = new THREE.CurvePath();

        //         // Part 1: Straight road section
        //         // A straight line is simply a LineCurve from start to end
        //         const straightPath = new THREE.LineCurve3(startPoint, straightEnd_Point);
        //         path.add(straightPath);

        //         // Part 2: 100-degree Arc at the end
        //         // Use an ArcCurve for the bend
        //         const arcPath = new THREE.ArcCurve(
        //             centerPoint.x, // x center
        //             centerPoint.z, // y center (z-axis in 3D)
        //             CURVE_RADIUS,  // radius
        //             THREE.MathUtils.degToRad(270), // start angle (270deg = straight up, if rotated around Z axis)
        //             THREE.MathUtils.degToRad(270 + 100), // end angle (270 + 100 = 370 or 10deg)
        //             false // Clockwise direction
        //         );

        //         // Since ArcCurve is 2D, we need a custom function or more complex path construction for a proper 3D road that starts at straightEnd_Point.

        //         // --- SIMPLER APPROACH USING SplineCurve for easy bending ---
        //         // Let's use a simpler, more common Three.js approach for curved roads: THREE.CatmullRomCurve3, which is good for smooth paths.

        //         const curvePoints = [
        //             new THREE.Vector3(x, 0.1, 0),                        // Start
        //             new THREE.Vector3(x, 0.1, straightEnd - 100),        // Control Point 1 (Straight)
        //             new THREE.Vector3(x, 0.1, straightEnd),              // Start of Curve
        //             new THREE.Vector3(x + 100, 0.1, straightEnd + 100),  // Mid-Curve Control Point
        //             new THREE.Vector3(x + 200, 0.1, straightEnd + 200)   // End Point (approximately 100 degrees turn)
        //         ];

        //         const curve = new THREE.CatmullRomCurve3(curvePoints);

        //         // 3. Generate TubeGeometry along the curve
        //         const roadGeometry = new THREE.TubeGeometry(
        //             curve,                 // path
        //             250,                   // segments (how smooth the path is)
        //             ROAD_WIDTH / 2,        // radius of the road profile
        //             6,                     // radial segments (how rounded the road side is)
        //             false                  // closed (false for open road)
        //         );

        //         road = new THREE.Mesh(roadGeometry, roadMaterial);

        //         // The position is already defined by the curve points, so we don't set a position here.

        //     } else {
        //         // All other longitudinal roads remain straight boxes
        //         const roadGeometry = new THREE.BoxGeometry(ROAD_WIDTH, 0.1, MAP_LENGTH);
        //         road = new THREE.Mesh(roadGeometry, roadMaterial);
        //         road.position.set(x, 0.1, MAP_LENGTH / 2);
        //     }

        //     road.receiveShadow = false;
        //     mapGroup.add(road);
        // }

        // // --- Transverse Roads (Horizontal - Z=constant, X=variable) ---
        // // (These remain unchanged, as they are not the road you wanted to curve)
        // const transRoads = 6;
        // const Z_START = 500;
        // const Z_END = MAP_LENGTH * 0.6; // 2800 * 0.6 = 1680
        // const transLength = Z_END - Z_START;
        // const transSpacing = transLength / (transRoads + 1);
        // transverseZ = []; // Clear array before population

        // for (let i = 1; i <= transRoads; i++) {
        //     const z = Z_START + transSpacing * i;
        //     transverseZ.push(z);
        //     const roadGeometry = new THREE.BoxGeometry(MAP_WIDTH, 0.1, ROAD_WIDTH);
        //     const road = new THREE.Mesh(roadGeometry, roadMaterial);
        //     road.position.set(MAP_WIDTH / 2, 0.1, z);
        //     road.receiveShadow = true;
        //     mapGroup.add(road);
        // }
        // }
        /**
         * Creates additional amenities like sports fields and the main highway.
         */
        function createAmenitiesAndRoads() {
            const fieldMaterial = new THREE.MeshLambertMaterial({ color: 0x388E3C });
            const amenityMaterial = new THREE.MeshLambertMaterial({ color: 0x9E9E9E });
            const highwayMaterial = new THREE.MeshLambertMaterial({ color: 0x212121 });

            // 1. Sports Fields (Bottom Middle) - placed in empty grid blocks
            const fieldSize = 100;
            const longRoads = 5;
            const longSpacing = MAP_WIDTH / (longRoads + 1);
            const blockOneXEnd = longSpacing;

            // Field 1: First X block (0 to ~267), low Z area (~50 to 500)
            const field1 = new THREE.Mesh(
                new THREE.BoxGeometry(fieldSize, 1, fieldSize * 2),
                fieldMaterial
            );
            field1.position.set(blockOneXEnd / 2, 0.5, 300);
            field1.receiveShadow = true;
            mapGroup.add(field1);

            // Field 2: Third X block (around the third road's center)
            // Center of the 3rd X block (between road 2 and road 3)
            const field2XCenter = (longitudinalX[1] + longitudinalX[2]) / 2;
            const field2 = new THREE.Mesh(
                new THREE.BoxGeometry(fieldSize, 1, fieldSize * 2),
                fieldMaterial
            );
            field2.position.set(field2XCenter, 0.5, 300);
            field2.receiveShadow = true;
            mapGroup.add(field2);

            // 2. Main Highway (Bottom)
            const highwayGeometry = new THREE.BoxGeometry(MAP_WIDTH + 600, 0.5, 100);
            const highway = new THREE.Mesh(highwayGeometry, highwayMaterial);
            highway.position.set(MAP_WIDTH / 2, 0.25, -50);
            highway.receiveShadow = true;
            mapGroup.add(highway);

            // 3. Main Entrance Gate Area (Bottom Center)
            const gateGeometry = new THREE.BoxGeometry(100, 25, 20);
            const gate = new THREE.Mesh(gateGeometry, amenityMaterial);
            gate.position.set(MAP_WIDTH / 2, 12.5, 0);
            gate.castShadow = true;
            mapGroup.add(gate);
        }

        /**
         * Populates the grid blocks defined by roads with houses.
         * Houses are placed in blocks between Z=50 (above highway) and Z=2000 (below residential spine).
         * Areas reserved for amenities are skipped.
         */
        function populateGridBlocks() {
            const HOUSE_WIDTH = 30;
            const HOUSE_LENGTH = 50;
            // Increased spacing for larger land area
            const HOUSE_X_SPACING = HOUSE_WIDTH + 30; // Was +10
            const HOUSE_Z_SPACING = HOUSE_LENGTH + 40; // Was +20

            // Define X boundaries: map edges and longitudinal roads
            const allXPositions = [0, ...longitudinalX, MAP_WIDTH];

            // Define Z boundaries: (Start of land) to (just below residential strip)
            const Z_MIN_LAND = 50;
            const Z_AMENITY_CUTOFF = 500; // Boundary for the low-Z amenity zone
            const Z_MAX_GRID_FILL = 2000; // Below the curved residential strip (Z=2100)

            // Filter transverseZ to only include roads below the curved residential strip
            const filteredTransverseZ = transverseZ.filter(z => z < Z_MAX_GRID_FILL && z > Z_MIN_LAND);

            // Rebuild allZPositions to ensure proper block segmentation
            let allZPositions = [Z_MIN_LAND, ...filteredTransverseZ, Z_MAX_GRID_FILL];
            // Add Z_AMENITY_CUTOFF if it's not already covered by transverse roads
            if (!filteredTransverseZ.some(z => Math.abs(z - Z_AMENITY_CUTOFF) < 5)) {
                allZPositions.push(Z_AMENITY_CUTOFF);
            }
            allZPositions.sort((a, b) => a - b);

            // X position of the longitudinal roads
            const longRoads = 5;
            const longSpacing = MAP_WIDTH / (longRoads + 1);

            // Loop through the X segments (blocks)
            // let houseCounter = 1; // Counter logic moved inside the block loop to reset per cluster

            for (let i = 0; i < allXPositions.length - 1; i++) {
                // Calculate effective block boundaries, accounting for road width
                const xStartRaw = allXPositions[i];
                const xEndRaw = allXPositions[i + 1];

                let xStart = xStartRaw + (i > 0 ? ROAD_WIDTH / 2 : 0);
                let xEnd = xEndRaw - (i < allXPositions.length - 2 ? ROAD_WIDTH / 2 : 0);

                // Handle edge case where the end is MAP_WIDTH and i is the last index (5)
                if (i === allXPositions.length - 2 && xEndRaw === MAP_WIDTH) {
                    xEnd = MAP_WIDTH;
                }

                const blockWidth = xEnd - xStart;
                if (blockWidth <= HOUSE_WIDTH) continue;


                // Loop through the Z segments (blocks)
                for (let j = 0; j < allZPositions.length - 1; j++) {
                    const zStartRaw = allZPositions[j];
                    const zEndRaw = allZPositions[j + 1];

                    // Calculate effective block boundaries, accounting for road width
                    // Z_MIN_LAND (50) and Z_MAX_GRID_FILL (2000) are assumed to be edges, not roads.
                    // The transverse roads are inside `filteredTransverseZ` which are the ones that require ROAD_WIDTH/2 offset.
                    let zStart = zStartRaw + (filteredTransverseZ.includes(zStartRaw) ? ROAD_WIDTH / 2 : 0);
                    let zEnd = zEndRaw - (filteredTransverseZ.includes(zEndRaw) ? ROAD_WIDTH / 2 : 0);

                    const blockLength = zEnd - zStart;
                    if (blockLength <= HOUSE_LENGTH) continue;

                    // --- Amenity Exclusion Logic ---
                    const isAmenityZone = zStartRaw >= Z_MIN_LAND && zEndRaw <= Z_AMENITY_CUTOFF;
                    // X blocks are 0, 1, 2, 3, 4, 5. Field 1 is in block 0. Field 2 is in block 2.
                    const isField1Block = i === 0;
                    const isField2Block = i === 2;

                    if (isAmenityZone && (isField1Block || isField2Block)) {
                        continue; // Skip blocks used by amenities
                    }

                    // Also skip the curved residential zone area buffer
                    if (zStartRaw >= Z_MAX_GRID_FILL - 100) {
                        continue;
                    }

                    // --- House Placement Logic ---
                    const housesX = Math.floor(blockWidth / HOUSE_X_SPACING);
                    const housesZ = Math.floor(blockLength / HOUSE_Z_SPACING);

                    // Skip if no room
                    if (housesX < 1 || housesZ < 1) continue;

                    // Calculate center point of the current block
                    const blockCenterX = (xStart + xEnd) / 2;
                    const blockCenterZ = (zStart + zEnd) / 2;

                    // Calculate starting offset to center the houses within the block
                    const startOffsetX = -((housesX - 1) * HOUSE_X_SPACING) / 2;
                    const startOffsetZ = -((housesZ - 1) * HOUSE_Z_SPACING) / 2;

                    // Reset counter for each cluster (Grid Block)
                    let houseCounter = 1;

                    for (let x = 0; x < housesX; x++) {
                        for (let z = 0; z < housesZ; z++) {
                            const houseID = `H-${houseCounter.toString().padStart(2, '0')}`;
                            const house = createHouseModel(HOUSE_WIDTH, HOUSE_LENGTH, houseID);
                            houseCounter++;

                            const houseX = blockCenterX + startOffsetX + x * HOUSE_X_SPACING;
                            const houseZ = blockCenterZ + startOffsetZ + z * HOUSE_Z_SPACING;

                            house.position.set(houseX, 0, houseZ);
                            mapGroup.add(house);
                        }
                    }
                }
            }
        }

        /**
         * Handles window resizing.
         */
        function onWindowResize() {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        /**
         * Handle mouse click/tap event for Raycasting
         */
        function onPointerDown(event) {
            // Calculate mouse position in normalized device coordinates
            // (-1 to +1) for both components
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Update the raycaster with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);

            // Calculate objects intersecting the picking ray
            // Intersect recursively with mapGroup children
            const intersects = raycaster.intersectObjects(mapGroup.children, true);

            if (intersects.length > 0) {
                // Get the first intersected object (closest to camera)
                let intersect = intersects[0];
                let obj = intersect.object;

                // Traverse up to find if we clicked a house group or a house part
                if (obj.userData.isHousePart || (obj.parent && obj.parent.userData.isHouse)) {
                    // Find the main group
                    let houseGroup = null;

                    if (obj.parent && obj.parent.userData.isHouse) {
                        houseGroup = obj.parent;
                    } else if (obj.userData.isHousePart && obj.parent) {
                        houseGroup = obj.parent;
                    }

                    if (houseGroup) {
                        selectHouse(houseGroup);
                    }
                } else {
                    // Clicked something else (ground, road, etc.)
                    deselectHouse(); // Deselect if clicking on empty ground or non-house object
                }
            } else {
                // Clicked sky
                deselectHouse();
            }
        }

        function selectHouse(group) {
            // If selecting the same house, do nothing
            if (selectedHouse === group) return;

            // 1. Deselect previous
            deselectHouse();

            // 2. Select new
            selectedHouse = group;

            // 3. Highlight ALL parts of the house group
            group.children.forEach(child => {
                // Check if the child is a part of the house that should be highlighted
                // (e.g., body, roof, dormer, door, etc., but not plot lines or trees)
                if ((child.userData.isHousePart || child.userData.isHouseBody) && child.material) {
                    // Ensure original color is saved if not already (should be set in createHouseModel)
                    if (child.userData.originalColor === undefined) {
                        child.userData.originalColor = child.material.color.getHex();
                    }

                    // Use the status-specific color stored in the group
                    child.material.color.setHex(group.userData.statusColor || SELECTED_COLOR);
                }
            });

            // 4. Show Popup
            showPopup(group.userData);
        }

        function deselectHouse() {
            if (selectedHouse) {
                // Restore colors for all children of the previously selected house
                selectedHouse.children.forEach(child => {
                    if ((child.userData.isHousePart || child.userData.isHouseBody) && child.userData.originalColor !== undefined && child.material) {
                        child.material.color.setHex(child.userData.originalColor);
                    }
                });
                selectedHouse = null;
            }
            hidePopup();
        }

        let hideTimeout = null;

        function showPopup(data) {
            const popup = document.getElementById('house-popup');
            const title = document.getElementById('popup-title');
            const idLabel = document.getElementById('popup-id');
            const statusLabel = document.getElementById('popup-status');

            // Clear any pending hide timeout to prevent accidental closing
            if (hideTimeout) {
                clearTimeout(hideTimeout);
                hideTimeout = null;
            }

            // Read data from the house object
            // data contains { id, status, statusColor, ... }
            const status = data.status || 'Available';
            const colorHex = data.statusColor ? '#' + data.statusColor.toString(16).padStart(6, '0') : '#000000';

            title.innerText = `House ${data.id}`;
            idLabel.innerText = `ID: #${data.id}`;
            statusLabel.innerText = status;

            // Set status text color to match the status highlight
            statusLabel.style.color = colorHex;
            statusLabel.className = "text-lg font-bold uppercase";

            // Show
            popup.classList.remove('hidden');
            // Small timeout to allow display:block to apply before transition
            setTimeout(() => {
                popup.classList.remove('translate-x-full');
            }, 10);
        }

        function hidePopup() {
            const popup = document.getElementById('house-popup');
            popup.classList.add('translate-x-full');

            // Clear existing timeout if any
            if (hideTimeout) {
                clearTimeout(hideTimeout);
            }

            // Wait for transition to finish before hiding
            hideTimeout = setTimeout(() => {
                popup.classList.add('hidden');
                hideTimeout = null;
            }, 300);
        }
        function animate() {
            // Only continue the loop if the renderer exists
            if (!renderer) return;

            requestAnimationFrame(animate);

            // Update controls only if they exist
            if (controls) {
                controls.update(); // Update controls in the loop
            }

            renderer.render(scene, camera);
        }

        // --- Start the application on window load ---
        window.onload = function () {

            init();

            // If init() succeeded, hide the overlay. If it failed, the error handler updated the overlay.
            if (renderer) {
                document.getElementById('loading-overlay').classList.add('hidden');
            }
        };

    </script>

</body>

</html>