<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Master Plan Layout</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Load OrbitControls (Requires THREE global object) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        /* Set the canvas to fill the entire viewport area */
        #container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #f0f0f0;
            /* Light background for contrast */
        }

        /* Hide scrollbars */
        body {
            overflow: hidden;
            font-family: 'Inter', sans-serif;
        }
    </style>
</head>

<body class="font-sans bg-gray-100">

    <!-- Three.js Container -->
    <div id="container"></div>

    <!-- Loading and Instruction Overlay -->
    <div id="loading-overlay"
        class="absolute inset-0 bg-gray-900 bg-opacity-90 flex flex-col items-center justify-center z-50 transition-opacity duration-500">
        <div class="text-white text-center p-8 rounded-lg">
            <svg class="animate-spin h-8 w-8 text-white mx-auto mb-4" xmlns="http://www.w3.org/2000/svg" fill="none"
                viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor"
                    d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">
                </path>
            </svg>
            <h1 class="text-3xl font-bold mb-4">Master Plan 3D Preview</h1>
            <p class="text-xl">Initializing 3D environment...</p>
        </div>
    </div>

    <!-- Instructions -->
    <div
        class="absolute top-4 left-4 p-4 bg-white/70 backdrop-blur-sm rounded-xl shadow-lg border border-gray-200 z-10 w-64">
        <h2 class="font-semibold text-lg text-gray-800 mb-2">Controls:Â </h2>
        <ul class="list-disc list-inside text-sm text-gray-700 space-y-1">
            <li><span class="font-medium">Left Click:</span> Select House</li>
            <li><span class="font-medium">Left Drag:</span> Rotate (Orbit)</li>
            <li><span class="font-medium">Right Drag:</span> Pan (Move)</li>
            <li><span class="font-medium">Scroll:</span> Zoom In / Out</li>
        </ul>
        <p class="mt-3 text-xs text-gray-600">This is an abstract 3D model representing the zoning of the master plan
            (Residential, River, Green Space, Roads).</p>
    </div>

    <!-- House Information Popup (Right Side) -->
    <div id="house-popup"
        class="absolute top-4 right-4 w-80 bg-white/90 backdrop-blur-md rounded-2xl shadow-2xl border border-gray-100 z-20 transform translate-x-full transition-transform duration-300 ease-in-out p-6 hidden">
        <div class="flex justify-between items-start mb-4">
            <div>
                <h2 class="text-2xl font-bold text-gray-800" id="popup-title">House Details</h2>
                <p class="text-sm text-gray-500" id="popup-id">ID: #---</p>
            </div>
            <button id="close-popup"
                class="bg-gray-100 hover:bg-gray-200 text-gray-600 rounded-full p-2 transition-colors">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd"
                        d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z"
                        clip-rule="evenodd" />
                </svg>
            </button>
        </div>

        <div class="space-y-4">
            <div class="bg-blue-50 p-4 rounded-xl border border-blue-100">
                <p class="text-xs font-semibold text-blue-600 uppercase tracking-wide mb-1">Status</p>
                <p class="text-lg font-medium text-blue-900" id="popup-status">Available</p>
            </div>

            <div class="grid grid-cols-2 gap-3">
                <div class="bg-gray-50 p-3 rounded-lg">
                    <p class="text-xs text-gray-500 mb-1">Area</p>
                    <p class="font-semibold text-gray-800">2,400 sqft</p>
                </div>
                <div class="bg-gray-50 p-3 rounded-lg">
                    <p class="text-xs text-gray-500 mb-1">Price</p>
                    <p class="font-semibold text-gray-800">$450,000</p>
                </div>
            </div>

            <div>
                <p class="text-sm text-gray-600 leading-relaxed">
                    Premium residential unit with view of the community park. Close to main highway entrance.
                </p>
            </div>

            <button
                class="w-full bg-blue-600 hover:bg-blue-700 text-white font-medium py-3 rounded-xl transition-colors shadow-lg shadow-blue-600/30 mt-2">
                Contact Agent
            </button>
        </div>
    </div>

    <script>
        // Global Three.js variables
        let scene, camera, renderer, controls;
        let mapGroup = new THREE.Group(); // Group to hold all map elements for easier manipulation

        // Raycaster for interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let selectedHouse = null;
        const SELECTED_COLOR = 0xFFC107; // Amber/Gold color for selection
        let originalHouseColor = null;

        // Global variables for road coordinates, needed for block calculation
        const ROAD_WIDTH = 20;
        let longitudinalX = [];
        let transverseZ = [];

        // --- Configuration: Increased Map Size ---
        const MAP_WIDTH = 4500; // Doubled width for a larger area
        const MAP_LENGTH = 3800; // Doubled length for a larger area

        /**
         * Initializes the Three.js scene, camera, renderer, and controls.
         */
        function init() {
            // Use try/catch to log errors during initialization, which helps debugging in the inspect panel.
            try {
                const container = document.getElementById('container');

                // 1. Scene Setup
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x01C3F5); // Lighter green sky/horizon

                // 2. Camera Setup
                camera = new THREE.PerspectiveCamera(
                    45,
                    window.innerWidth / window.innerHeight,
                    1,
                    50000
                );
                // Position the camera high up, looking down onto the new center of the map
                camera.position.set(MAP_WIDTH / 2, 4000, -1500);
                camera.lookAt(MAP_WIDTH / 2, 0, MAP_LENGTH / 2);

                // 3. Renderer Setup
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.shadowMap.enabled = true; // Enable shadow maps
                container.appendChild(renderer.domElement);

                // Add the map group to the scene
                scene.add(mapGroup);

                // 4. Controls Setup (OrbitControls)
                // Check if controls are available (often a failure point if the CDN script didn't load)
                if (typeof THREE.OrbitControls === 'undefined') {
                    console.error("Error: THREE.OrbitControls not loaded. Check the CDN script link in the head.");
                    return; // Stop initialization if controls are missing
                }
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.target.set(MAP_WIDTH / 2, 0, MAP_LENGTH / 2); // Center controls on the map
                controls.maxPolarAngle = Math.PI / 4.2; // Prevent camera from going under the ground
                controls.enableDamping = true; // For a smoother feel
                controls.dampingFactor = 0.05;

                // 5. Lighting
                addLighting();

                // 6. Create Map Elements
                createGroundAndBoundary();
                // createRiver();

                // createGridRoads(); // Must run first to populate road arrays
                // createAmenitiesAndRoads(); // Uses road positions for placement, placed before blocks to reserve space
                createLine1_Cluster(); // Right-most (Land 1)
                createLine2_Cluster(); // Center-Right (Land 2)
                createLine3_Bunch();   // Center-Left (Land 3)
                // createLine4_Empty();   // Left-most (Land 4)
                createResidentialBlocks(); // Curved strip is still separate

                // 7. Event Listeners
                // 7. Event Listeners
                window.addEventListener('resize', onWindowResize);
                window.addEventListener('pointerdown', onPointerDown); // Use pointerdown for better mobile/desktop handling

                // Close button listener
                document.getElementById('close-popup').addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent triggering map click
                    deselectHouse();
                });

                // Start the animation loop
                animate();

            } catch (error) {
                console.error("FATAL ERROR during Three.js initialization:", error);
                document.getElementById('loading-overlay').innerHTML = `
                    <div class="text-white text-center p-8 rounded-xl bg-red-700">
                        <h1 class="text-3xl font-bold mb-4">Initialization Error</h1>
                        <p class="text-lg">The 3D scene failed to load. Please check the browser console for details to debug the issue.</p>
                        <p class="text-sm mt-4 italic">Error: ${error.message}</p>
                    </div>
                `;
            }
        }

        /**
         * Adds lighting to the scene.
         */
        function addLighting() {
            // Ambient light for general scene illumination
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            // Directional light (Simulating the sun)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(500, 1500, 500); // Position high and slightly offset
            directionalLight.castShadow = true;

            // Configure shadow properties
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            const d = 1000;
            directionalLight.shadow.camera.left = -d;
            directionalLight.shadow.camera.right = d;
            directionalLight.shadow.camera.top = d;
            directionalLight.shadow.camera.bottom = -d;
            directionalLight.shadow.camera.near = 100;
            directionalLight.shadow.camera.far = 3000;

            scene.add(directionalLight);
        }

        /**
         * Creates the main ground plane (green area) and a base boundary. 0x558B2F
         */
        function createGroundAndBoundary() {
            // Base plane (Main Green Area - now much larger)
            const groundGeometry = new THREE.PlaneGeometry(MAP_WIDTH + 2600, MAP_LENGTH + 600);
            const groundMaterial = new THREE.MeshBasicMaterial({
                color: 0x62bf41,
                polygonOffset: true,
                polygonOffsetFactor: 1,   // ground goes BACK
                polygonOffsetUnits: 1
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2; // Rotate to lie flat
            ground.position.set(MAP_WIDTH / 2, -1, MAP_LENGTH / 2);
            ground.receiveShadow = true;
            mapGroup.add(ground);

            // Central Development Land (lighter green - also larger)

            const landGeometry = new THREE.PlaneGeometry(MAP_WIDTH + 2200, MAP_LENGTH + 200);
            const landMaterial = new THREE.MeshBasicMaterial({
                color: 0xe6ff82,
                polygonOffset: true,
                polygonOffsetFactor: 1,   // ground goes BACK
                polygonOffsetUnits: 1
            }); // Lighter green for development land

            const land = new THREE.Mesh(landGeometry, landMaterial);
            land.rotation.x = -Math.PI / 2;
            land.position.set(MAP_WIDTH / 2, 0, MAP_LENGTH / 2);
            land.receiveShadow = true;
            mapGroup.add(land);
        }

        /**
         * Creates the main river path, now located outside the enlarged primary land area.
         */
        function createRiver() {
            // Increased offset to keep the river outside the new, larger MAP_LENGTH boundary (3000)
            const Z_OFFSET = 600;

            const riverPoints2D = [
                // X coordinates are scaled, Z coordinates are relative to the new map length
                new THREE.Vector2(-200, MAP_LENGTH + 50 + Z_OFFSET),
                new THREE.Vector2(400, MAP_LENGTH - 100 + Z_OFFSET),
                new THREE.Vector2(800, MAP_LENGTH + 50 + Z_OFFSET), // New center X
                new THREE.Vector2(1200, MAP_LENGTH - 50 + Z_OFFSET),
                new THREE.Vector2(MAP_WIDTH + 200, MAP_LENGTH + 50 + Z_OFFSET),
            ];

            // Convert 2D points to 3D points (y is up). 
            const riverPoints3D = riverPoints2D.map(p => new THREE.Vector3(p.x, -0.5, p.y));

            // Create a smooth curve using CatmullRomCurve3
            const curve = new THREE.CatmullRomCurve3(riverPoints3D, false, 'centripetal');

            const riverRadius = 80; // Slightly wider river
            const tubularSegments = 200;
            const radialSegments = 4;

            // Create TubeGeometry along the curve
            const riverGeometry = new THREE.TubeGeometry(
                curve,
                tubularSegments,
                riverRadius,
                radialSegments,
                false
            );

            // Material for deeper water color and higher opacity
            const riverMaterial = new THREE.MeshLambertMaterial({
                color: 0x0056a0, // Darker blue water
                transparent: true,
                opacity: 0.85
            });

            const riverMesh = new THREE.Mesh(riverGeometry, riverMaterial);
            riverMesh.receiveShadow = true;
            mapGroup.add(riverMesh);
        }

        /**
         * Creates a simple low-poly tree.
         */
        function createTree() {
            const treeGroup = new THREE.Group();

            // Trunk
            const trunkGeometry = new THREE.CylinderGeometry(1.5, 1.5, 6, 6);
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8D6E63 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 3; // Half height
            trunk.castShadow = true;
            treeGroup.add(trunk);

            // Foliage (two cones for better look)
            const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x388E3C });

            const lowerCone = new THREE.Mesh(new THREE.ConeGeometry(5, 8, 8), leavesMaterial);
            lowerCone.position.y = 8;
            lowerCone.castShadow = true;
            treeGroup.add(lowerCone);

            const upperCone = new THREE.Mesh(new THREE.ConeGeometry(4, 7, 8), leavesMaterial);
            upperCone.position.y = 12;
            upperCone.castShadow = true;
            treeGroup.add(upperCone);

            return treeGroup;
        }

        /**
         * Creates a single house model with plot border and tree.
         */
        function createHouseModel(width, length, id) {
            const houseGroup = new THREE.Group();
            const bodyHeight = 12;

            // Generate Random Status
            // 40% Available, 30% Sold, 20% Reserved, 10% Booked
            const rand = Math.random();
            let status = 'Available';
            let statusColor = 0x4CAF50; // Green

            if (rand > 0.9) {
                status = 'Booked';
                statusColor = 0x2196F3; // Blue
            } else if (rand > 0.7) {
                status = 'Reserved';
                statusColor = 0xFF9800; // Orange
            } else if (rand > 0.4) {
                status = 'Sold';
                statusColor = 0xF44336; // Red
            }

            // Store status in user data for selection logic
            houseGroup.userData.isHouse = true;
            houseGroup.userData.id = id;
            houseGroup.userData.status = status;
            houseGroup.userData.statusColor = statusColor;



            // --- Plot Boundary (Dotted Line) ---
            // Increased plot buffer for "Larger Land Area"
            const plotWidth = width + 25;
            const plotLength = length + 35;

            // Create a rectangle shape for the plot
            const plotGeometry = new THREE.EdgesGeometry(new THREE.PlaneGeometry(plotWidth, plotLength));
            const plotMaterial = new THREE.LineDashedMaterial({
                color: 0xaaaaaa,
                dashSize: 4,  // Bigger dashes
                gapSize: 3,
                opacity: 0.6,
                transparent: true
            });

            const plotLines = new THREE.LineSegments(plotGeometry, plotMaterial);
            plotLines.rotation.x = -Math.PI / 2; // Lie flat on ground
            plotLines.position.y = 0.2;
            plotLines.computeLineDistances();
            houseGroup.add(plotLines);

            // --- House Body (White/Cream) ---
            const bodyGeometry = new THREE.BoxGeometry(width, bodyHeight, length);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0xf5f5f5 });
            const houseBody = new THREE.Mesh(bodyGeometry, bodyMaterial);
            houseBody.position.y = bodyHeight / 2;
            houseBody.castShadow = true;

            // Mark as house part and store parent reference if needed
            houseBody.userData.isHousePart = true;
            houseBody.userData.originalColor = bodyMaterial.color.getHex();

            houseGroup.add(houseBody);
            // --- Pitched Roof (Gable Style) ---
            const roofHeight = 6;
            const roofWidth = width * 1.2;
            const roofLength = length * 1.1;

            const shape = new THREE.Shape();
            shape.moveTo(0, 0);
            shape.lineTo(roofWidth / 2, roofHeight);
            shape.lineTo(roofWidth, 0);
            shape.lineTo(0, 0);

            const extrudeSettings = {
                steps: 1,
                depth: roofLength,
                bevelEnabled: false
            };

            const gableGeometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            gableGeometry.translate(-roofWidth / 2, 0, -roofLength / 2);

            const roofMaterial = new THREE.MeshLambertMaterial({ color: 0x8e554a });
            const gableRoof = new THREE.Mesh(gableGeometry, roofMaterial);
            gableRoof.position.y = bodyHeight;
            gableRoof.castShadow = true;

            // Interaction Tags
            gableRoof.userData.isHousePart = true;
            gableRoof.userData.originalColor = roofMaterial.color.getHex();

            houseGroup.add(gableRoof);

            // --- Dormer (Small extension) ---
            const dormerWidth = roofWidth * 0.4;
            const dormerHeight = roofHeight * 0.6;
            const dormerLength = roofWidth * 0.4;

            const dormerShape = new THREE.Shape();
            dormerShape.moveTo(0, 0);
            dormerShape.lineTo(dormerWidth / 2, dormerHeight);
            dormerShape.lineTo(dormerWidth, 0);
            dormerShape.lineTo(0, 0);

            const dormerGeo = new THREE.ExtrudeGeometry(dormerShape, {
                steps: 1,
                depth: dormerLength,
                bevelEnabled: false
            });
            dormerGeo.translate(-dormerWidth / 2, 0, 0);

            const dormer = new THREE.Mesh(dormerGeo, roofMaterial);
            dormer.rotation.y = Math.PI / 2;
            dormer.position.set(roofWidth / 3, bodyHeight + 1.5, 0);

            // Interaction Tags
            dormer.userData.isHousePart = true;
            dormer.userData.originalColor = roofMaterial.color.getHex();

            houseGroup.add(dormer);

            // Window on Dormer
            const winGeo = new THREE.PlaneGeometry(dormerWidth * 0.4, dormerHeight * 0.4);
            const winMat = new THREE.MeshLambertMaterial({ color: 0x87CEEB });
            const windowMesh = new THREE.Mesh(winGeo, winMat);
            windowMesh.rotation.y = Math.PI / 2;
            windowMesh.position.set(roofWidth / 3 + dormerLength + 0.1, bodyHeight + 2.5, 0);
            houseGroup.add(windowMesh);

            // --- Create Door Texture with Number ---
            // Helper function logic inline or separate? Let's keep it clean.
            // Since we didn't add the helper function globally yet, let's just generate the canvas here.

            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            // Draw Door Background
            ctx.fillStyle = '#8D6E63'; // Wood color
            ctx.fillRect(0, 0, 128, 256);

            // Draw Panel details
            ctx.strokeStyle = '#5D4037';
            ctx.lineWidth = 5;
            ctx.strokeRect(10, 10, 108, 236);

            // Draw Number
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 60px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(id, 64, 80); // Top half

            const doorTexture = new THREE.CanvasTexture(canvas);

            // Simplified door/window proxies
            const doorHeight = bodyHeight * 0.9;
            const doorGeometry = new THREE.BoxGeometry(width * 0.25, doorHeight, 0.1);
            const doorMaterial = new THREE.MeshLambertMaterial({ map: doorTexture });
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(0, doorHeight / 2, length / 2 + 0.05);
            houseGroup.add(door);

            // --- Add Side Door (Under Dormer) ---
            // Dormer is at x = roofWidth / 3.
            // roofWidth = width * 1.2
            // So dormerX = (width * 1.2) / 3 = width * 0.4

            // Side Door Geometry (Same as front)
            const sideDoor = new THREE.Mesh(doorGeometry, doorMaterial);

            // Position:
            // X: width / 2 + 0.05 (Outside the wall)
            // Y: doorHeight / 2
            // Z: 0 (Centered, as dormer is centered)

            sideDoor.position.set(width / 2 + 0.05, doorHeight / 2, 0);
            sideDoor.rotation.y = Math.PI / 2; // Rotate to face outward (+X)

            houseGroup.add(sideDoor);

            // --- Add Tree ---
            const tree = createTree();
            // Position tree in the corner of the plot
            // Moved to "Opposite" side (Front instead of Back)
            const cornerX = (plotWidth / 2) - 8;
            const cornerZ = (plotLength / 2) - 8; // Front corner (Positive Z)

            // Place on left or right side randomly
            const side = Math.random() > 0.5 ? 1 : -1;
            tree.position.set(side * cornerX, 0, cornerZ);

            houseGroup.add(tree);

            return houseGroup;
        }


        /**
         * Creates the residential strips following a curved layout.
         */
        /**
         * Creates the residential strips following a curved layout with clustered blocks and a river.
         */
        function createResidentialBlocks() {
            // Updated Material for the "Green Spine" (previously road)
            const greenCentralMaterial = new THREE.MeshLambertMaterial({ color: 0x8BC34A }); // Same as development land
            // Material for the Road Divider
            const roadDividerMaterial = new THREE.MeshBasicMaterial({
                color: 0x515151,
                polygonOffset: true,
                polygonOffsetFactor: -1,
                polygonOffsetUnits: -1
            });

            const HOUSE_WIDTH = 82; // Match Line 1/2/3 style
            const HOUSE_LENGTH = 92; // Match Line 1/2/3 style
            // HOUSE_SPACING is now calculated automatically

            // Block Configuration: 4 Zones with specified house counts
            const blockCounts = [17, 56, 29, 17]; // Zone A, B, C, D
            const zoneNames = ['A', 'B', 'C', 'D'];
            const totalHousesInBlocks = blockCounts.reduce((a, b) => a + b, 0);
            // Separation between the two house strips - now dynamic
            const STRIP_START_SEPARATION = HOUSE_LENGTH * 1.5;
            const STRIP_END_SEPARATION = HOUSE_LENGTH * 4.0; // Widen significantly at the end

            const getStripSeparation = (t) => {
                return STRIP_START_SEPARATION + (STRIP_END_SEPARATION - STRIP_START_SEPARATION) * t;
            };

            // Helper to create tapered geometry
            const createTaperedGeometry = (widthStart, widthEnd, length, height) => {
                const shape = new THREE.Shape();
                shape.moveTo(-widthStart / 2, -length / 2);
                shape.lineTo(widthStart / 2, -length / 2);
                shape.lineTo(widthEnd / 2, length / 2);
                shape.lineTo(-widthEnd / 2, length / 2);
                shape.lineTo(-widthStart / 2, -length / 2);

                const extrudeSettings = { depth: height, bevelEnabled: false };
                const geometry = new THREE.ExtrudeBufferGeometry(shape, extrudeSettings);
                geometry.rotateX(Math.PI / 2);
                return geometry;
            };

            // --- Curve Definition - Following Line 3 Left Road Path ---
            // CHL now follows the same curve as Line 3's left road
            // We'll create points that match the Line 3 left road curve

            // Get Line 3 bunch specifications to calculate curve points
            const line3BunchSpecs = [
                { houses: 30 }, // Bunch 6
                { houses: 28 }, // Bunch 5
                { houses: 24 }, // Bunch 4
                { houses: 28 }, // Bunch 3
                { houses: 28 }, // Bunch 2
                { houses: 36 }  // Bunch 1
            ];

            const HOUSE_WIDTH_L3 = 64;
            const HOUSE_DEPTH_L3 = 68;
            const UNIT_GAP_L3 = 66;
            const UNIT_WIDTH_L3 = (HOUSE_WIDTH_L3 * 2) + UNIT_GAP_L3;
            const UNIT_X_SPACING_L3 = UNIT_WIDTH_L3 - 70;
            const CLUSTER_ROAD_GAP_L3 = 180;
            const CLUSTER_INTERNAL_GAP_L3 = 60;
            const BLOCK_HEIGHT_L3 = (HOUSE_DEPTH_L3 * 1.2) + CLUSTER_INTERNAL_GAP_L3;

            // Calculate Line 3 positions
            const LINE2_WIDTH = (8 * UNIT_X_SPACING_L3) + 100;
            const LINE_TOTAL_WIDTH_L3 = (18 * UNIT_X_SPACING_L3) + 100;
            const X_MAX_LINE3 = MAP_WIDTH - LINE2_WIDTH - LINE_TOTAL_WIDTH_L3;

            // Build curve points matching Line 3's left road
            const chlCurvePoints = [];
            let currentZ_CHL = 250;

            // Start point - offset from Line 3 left road start for spacing
            const startBunchWidth = (line3BunchSpecs[0].houses / 2) * UNIT_X_SPACING_L3;
            const startX = X_MAX_LINE3 - startBunchWidth - 140;
            const CHL_SPACING_OFFSET = -1000; // Distance between CHL and Line 3 road
            chlCurvePoints.push(new THREE.Vector3(startX - CHL_SPACING_OFFSET, 0, 0));

            // Add points for each bunch endpoint - following Line 3 left road exactly
            line3BunchSpecs.forEach((bunch) => {
                const unitsCount = bunch.houses / 2;
                const cWidth = unitsCount * UNIT_X_SPACING_L3;
                currentZ_CHL += BLOCK_HEIGHT_L3;
                const roadZ = currentZ_CHL + CLUSTER_ROAD_GAP_L3 / 2;
                const leftEndX = X_MAX_LINE3 - cWidth - 140;

                chlCurvePoints.push(new THREE.Vector3(leftEndX - CHL_SPACING_OFFSET, 0, roadZ));
                currentZ_CHL += CLUSTER_ROAD_GAP_L3;
            });

            // Add transition and end point
            const lastPoint = chlCurvePoints[chlCurvePoints.length - 1];
            chlCurvePoints.push(new THREE.Vector3(lastPoint.x, 0, lastPoint.z + 300));
            // chlCurvePoints.push(new THREE.Vector3(MAP_WIDTH - 100, 0, MAP_LENGTH * 0.85));
            chlCurvePoints.push(new THREE.Vector3(MAP_WIDTH - 100, 0, MAP_LENGTH * 0.85 + 600));

            const residentialCurve = new THREE.CatmullRomCurve3(
                chlCurvePoints,
                false, 'centripetal'
            );

            // --- Auto-Calculate Spacing ---
            const curveLength = residentialCurve.getLength();
            const gapSizeMultiplier = 4; // Gap = N * Spacing

            const totalPairs = Math.ceil(totalHousesInBlocks / 2);
            const numGaps = blockCounts.length - 1;
            const HOUSE_SPACING = curveLength / (totalPairs + (numGaps * gapSizeMultiplier));

            // console.log("Auto-calculated Spacing:", HOUSE_SPACING);

            // --- Control Points for Identity ---
            // Visual markers for Start and End of the curve
            const markerGeometry = new THREE.SphereGeometry(30, 32, 32);

            // Start Point (Green)
            const startPoint = residentialCurve.getPoint(0);
            const startMarker = new THREE.Mesh(markerGeometry, new THREE.MeshLambertMaterial({ color: 0x00FF00 }));
            startMarker.position.copy(startPoint);
            startMarker.position.y = 15;
            mapGroup.add(startMarker);

            // End Point (Red)
            const endPoint = residentialCurve.getPoint(1);
            const endMarker = new THREE.Mesh(markerGeometry, new THREE.MeshLambertMaterial({ color: 0xFF0000 }));
            endMarker.position.copy(endPoint);
            endMarker.position.y = 15;
            mapGroup.add(endMarker);


            // --- Create Center Divider Road (between house area and river) ---
            const centerRoadPoints = [];
            const centerDivisions = 350;
            for (let i = 0; i <= centerDivisions; i++) {
                const t = i / centerDivisions;
                const point = residentialCurve.getPoint(t);
                const tangent = residentialCurve.getTangent(t).normalize();
                const normal = new THREE.Vector3(-tangent.z, 0, tangent.x);

                // Offset to position between house area and river - now dynamic
                const centerRoadOffset = getStripSeparation(t) / 2 + 50;
                const roadPos = point.clone().add(normal.clone().multiplyScalar(centerRoadOffset));
                centerRoadPoints.push(roadPos);
            }

            const centerRoadCurve = new THREE.CatmullRomCurve3(centerRoadPoints);
            const centerRoadGeometry = new THREE.TubeGeometry(centerRoadCurve, 250, 25, 8, false); // Width 25 (Radius 25)

            const centerRoadMaterial = new THREE.MeshBasicMaterial({
                color: 0x515151,
                polygonOffset: true,
                polygonOffsetFactor: -1,
                polygonOffsetUnits: -1
            });

            const centerRoadMesh = new THREE.Mesh(centerRoadGeometry, centerRoadMaterial);
            centerRoadMesh.position.y = 0.5; // Just above ground
            // Flatten to look like a road
            centerRoadMesh.scale.set(1, 0.05, 1);

            mapGroup.add(centerRoadMesh);


            // --- Create Parallel Road (formerly River) ---
            const parallelRoadPoints = [];
            const divisions = 350;
            for (let i = 0; i <= divisions; i++) {
                const t = i / divisions;
                const point = residentialCurve.getPoint(t);
                const tangent = residentialCurve.getTangent(t).normalize();
                const normal = new THREE.Vector3(-tangent.z, 0, tangent.x);

                // Offset to "Outer" side relative to the curve direction - now dynamic
                const roadOffsetDistance = getStripSeparation(t) + 100;
                const roadPos = point.clone().add(normal.clone().multiplyScalar(roadOffsetDistance));
                parallelRoadPoints.push(roadPos);
            }

            const parallelRoadCurve = new THREE.CatmullRomCurve3(parallelRoadPoints);
            const parallelRoadGeometry = new THREE.TubeGeometry(parallelRoadCurve, 250, 70, 8, false); // Width 70 (Radius 70)

            // "Road Style": Grey color, flat appearance
            const parallelRoadMaterial = new THREE.MeshBasicMaterial({
                color: 0x74f7e3,
                polygonOffset: true,
                polygonOffsetFactor: -1,
                polygonOffsetUnits: -1
            });

            const parallelRoadMesh = new THREE.Mesh(parallelRoadGeometry, parallelRoadMaterial);
            parallelRoadMesh.position.y = .5; // Just above ground
            // Flatten to look like a road
            parallelRoadMesh.scale.set(1, 0.05, 1);

            mapGroup.add(parallelRoadMesh);


            // --- Place Houses in Blocks ---
            const zoneLengths = [2000, 5000, 5000, 2000];
            const zoneSpacings = [350, 450, 550, 650]; // Custom spacing per zone A, B, C, D
            const roadGap = 10;
            const roadGapT = roadGap / curveLength;
            const zoneCount = blockCounts.length;

            let runningT = 0;

            blockCounts.forEach((count, blockIndex) => {
                const zoneName = zoneNames[blockIndex];
                const segmentLength = zoneLengths[blockIndex];
                const segmentT = segmentLength / curveLength;
                const endT = runningT + segmentT;

                const pairs = Math.ceil(count / 2);
                const currentSpacing = zoneSpacings[blockIndex];
                const spacingT = currentSpacing / curveLength;

                let zoneHouseCounter = 1;
                let localT = runningT;

                // 1. Place Houses for this segment
                // We use count to stay within user's intended house numbers,
                // but we also stop if we exceed the physical segment length.
                for (let i = 0; i < pairs; i++) {
                    const currentT = localT;
                    if (currentT >= endT || currentT >= 1) break;

                    const point = residentialCurve.getPoint(currentT);
                    const tangent = residentialCurve.getTangent(currentT).normalize();
                    const normal = new THREE.Vector3(-tangent.z, 0, tangent.x);

                    const currentStripSeparation = getStripSeparation(currentT);

                    // --- Inner Strip (Odd houses) ---
                    if (zoneHouseCounter <= count) {
                        const innerOffset = normal.clone().multiplyScalar(-currentStripSeparation / 2);
                        const innerPosition = point.clone().add(innerOffset);

                        const id1 = `CHL-Zone${zoneName}-${zoneHouseCounter}`;
                        const house1 = createHouseModel(HOUSE_WIDTH / 2 - 2, HOUSE_LENGTH, id1);
                        house1.userData.type = 'CHL';
                        house1.userData.zone = zoneName;

                        house1.rotation.y = Math.atan2(normal.x, normal.z);
                        house1.position.copy(innerPosition);
                        mapGroup.add(house1);

                        // Add border
                        const borderGeo = new THREE.BoxGeometry(HOUSE_WIDTH / 2 + 4, 0.1, HOUSE_LENGTH + 4);
                        const borderMat = new THREE.MeshLambertMaterial({ color: 0x8B4513, transparent: true, opacity: 0.3 });
                        const border1 = new THREE.Mesh(borderGeo, borderMat);
                        border1.position.copy(innerPosition);
                        border1.position.y = 0.05;
                        border1.rotation.y = house1.rotation.y;
                        mapGroup.add(border1);

                        zoneHouseCounter++;
                    }

                    // --- Outer Strip (Even houses) ---
                    if (zoneHouseCounter <= count) {
                        const outerOffset = normal.clone().multiplyScalar(currentStripSeparation / 2);
                        const outerPosition = point.clone().add(outerOffset);

                        const id2 = `CHL-Zone${zoneName}-${zoneHouseCounter}`;
                        const house2 = createHouseModel(HOUSE_WIDTH / 2 - 2, HOUSE_LENGTH, id2);
                        house2.userData.type = 'CHL';
                        house2.userData.zone = zoneName;

                        house2.rotation.y = Math.atan2(normal.x, normal.z);
                        house2.position.copy(outerPosition);
                        mapGroup.add(house2);

                        // Add border
                        const border2 = new THREE.Mesh(new THREE.BoxGeometry(HOUSE_WIDTH / 2 + 4, 0.1, HOUSE_LENGTH + 4),
                            new THREE.MeshLambertMaterial({ color: 0x8B4513, transparent: true, opacity: 0.3 }));
                        border2.position.copy(outerPosition);
                        border2.position.y = 0.05;
                        border2.rotation.y = house2.rotation.y;
                        mapGroup.add(border2);

                        zoneHouseCounter++;
                    }

                    // --- Green Land Spine (Tapered) ---
                    const midT = currentT + (spacingT / 2);
                    if (midT < endT && midT < 1) {
                        const widthStart = getStripSeparation(currentT) * 1.1;
                        const widthEnd = getStripSeparation(currentT + spacingT) * 1.1;
                        const spineLength = currentSpacing * 1.1;

                        const spineGeo = createTaperedGeometry(widthStart, widthEnd, spineLength, 0.5);
                        const spine = new THREE.Mesh(spineGeo, greenCentralMaterial);

                        const midPoint = residentialCurve.getPoint(midT);
                        const midTangent = residentialCurve.getTangent(midT).normalize();
                        spine.position.copy(midPoint);
                        spine.position.y = 0.1;
                        spine.rotation.y = Math.atan2(midTangent.x, midTangent.z);
                        mapGroup.add(spine);
                    }

                    localT += spacingT;
                }

                // 2. Add Road Divider after the segment
                if (blockIndex < zoneCount - 1) {
                    const dividerT = endT + (roadGapT / 2);
                    if (dividerT < 1) {
                        const point = residentialCurve.getPoint(dividerT);
                        const tangent = residentialCurve.getTangent(dividerT).normalize();

                        const roadWidth = 40;
                        const dividerWidth = getStripSeparation(dividerT) * 2.5;

                        const divider = new THREE.Mesh(new THREE.BoxGeometry(dividerWidth, 0.2, roadWidth), roadDividerMaterial);
                        divider.position.copy(point);
                        divider.position.y = 0.15;
                        divider.rotation.y = Math.atan2(tangent.x, tangent.z);
                        mapGroup.add(divider);
                    }
                }

                runningT = endT + roadGapT;
            });
        }

        /**
         * Creates a grid of roads across the main map area and stores their coordinates.
         */
        // function createGridRoads() {
        //     const roadMaterial = new THREE.MeshLambertMaterial({ color: 0x212121 });

        //     // Longitudinal Roads (Vertical - X=constant, Z=variable)
        //     const longRoads = 5;
        //     const longSpacing = MAP_WIDTH / (longRoads + 1);
        //     longitudinalX = []; // Clear array before population
        //     for (let i = 1; i <= longRoads; i++) {
        //         const x = longSpacing * i;
        //         longitudinalX.push(x);
        //         const roadGeometry = new THREE.BoxGeometry(ROAD_WIDTH, 0.1, MAP_LENGTH);
        //         const road = new THREE.Mesh(roadGeometry, roadMaterial);
        //         road.position.set(x, 0.1, MAP_LENGTH / 2);
        //         road.receiveShadow = true;
        //         mapGroup.add(road);
        //     }

        //     // Transverse Roads (Horizontal - Z=constant, X=variable)
        //     const transRoads = 6;
        //     const Z_START = 500;
        //     const Z_END = MAP_LENGTH * 0.6; // 2800 * 0.6 = 1680
        //     const transLength = Z_END - Z_START;
        //     const transSpacing = transLength / (transRoads + 1);
        //     transverseZ = []; // Clear array before population

        //     for (let i = 1; i <= transRoads; i++) {
        //         const z = Z_START + transSpacing * i;
        //         transverseZ.push(z);
        //         const roadGeometry = new THREE.BoxGeometry(MAP_WIDTH, 0.1, ROAD_WIDTH);
        //         const road = new THREE.Mesh(roadGeometry, roadMaterial);
        //         road.position.set(MAP_WIDTH / 2, 0.1, z);
        //         road.receiveShadow = true;
        //         mapGroup.add(road);
        //     }
        // }

        function createGridRoads() {
            // Define a single material for ALL roads
            const roadMaterial = new THREE.MeshBasicMaterial({
                color: 0x74f7e3,
                polygonOffset: true,
                polygonOffsetFactor: -1,
                polygonOffsetUnits: -1
            });

            // --- Longitudinal Roads (Vertical dividers) ---
            const longRoads = 3;
            const longSpacing = MAP_WIDTH / (longRoads + 1);
            longitudinalX = [];

            for (let i = 1; i <= longRoads; i++) {
                const x = longSpacing * i;
                longitudinalX.push(x);

                // Standard straight road
                const roadGeometry = new THREE.BoxGeometry(ROAD_WIDTH, 0.1, MAP_LENGTH);
                const road = new THREE.Mesh(roadGeometry, roadMaterial);
                road.position.set(x, 0.1, MAP_LENGTH / 2);
                road.receiveShadow = true;
                mapGroup.add(road);
            }

            // --- Transverse Roads (Horizontal - Segmented by Column) ---
            const transRoads = 4; // 10 rows
            const Z_START = 500;
            const Z_END = 3500;
            const transLength = Z_END - Z_START;
            const transSpacing = transLength / (transRoads + 1);

            transverseZ = []; // Store Z coords for grid population

            // Populate transverseZ array first
            for (let j = 1; j <= transRoads; j++) {
                const z = Z_START + transSpacing * j;
                transverseZ.push(z);
            }

            // Create Segmented Roads
            const numCols = longRoads + 1; // 4 columns
            const colWidth = MAP_WIDTH / numCols;

            for (let j = 0; j < transverseZ.length; j++) {
                const z = transverseZ[j];
                const rowIndex = j; // 0 to 8

                for (let col = 0; col < numCols; col++) {
                    const i = col;

                    // --- Visibility Logic (Same as Rows) ---
                    // col=0 (Left): Land 4 (CHL) -> Hide Roads
                    if (i === 0) continue;

                    // col=1: Land 3 -> Show Rows 0-7. Hide >7.
                    if (i === 1 && rowIndex > 7) continue;

                    // col=2: Land 2 -> Show Rows 0-6. Hide >6.
                    if (i === 2 && rowIndex > 6) continue;

                    // col=3 (Right): Land 1 -> Show Rows 7-9. Hide <7.
                    if (i === 3 && rowIndex < 7) continue;

                    // Create Road Segment
                    const roadSegGeo = new THREE.BoxGeometry(colWidth, 0.1, ROAD_WIDTH);
                    const roadSeg = new THREE.Mesh(roadSegGeo, roadMaterial);

                    // Position X at center of column
                    const centerX = (col * colWidth) + (colWidth / 2);
                    roadSeg.position.set(centerX, 0.1, z);
                    roadSeg.receiveShadow = false;
                    mapGroup.add(roadSeg);
                }
            }
        }

        // function createGridRoads() {
        // const roadMaterial = new THREE.MeshLambertMaterial({ color: 0x212121 });
        // const CURVE_START_Z = MAP_LENGTH * 0.8; // Z-coordinate where the curve starts (e.g., 80% up the map)
        // const CURVE_LENGTH = MAP_LENGTH * 0.2; // Length over which the curve happens
        // const CURVE_RADIUS = 500; // Radius of the curve for the bend

        // // --- Longitudinal Roads (Vertical - X=constant, Z=variable) ---
        // const longRoads = 5;
        // const longSpacing = MAP_WIDTH / (longRoads + 1);
        // longitudinalX = []; // Clear array before population

        // for (let i = 1; i <= longRoads; i++) {
        //     const x = longSpacing * i;
        //     longitudinalX.push(x);

        //     let road;

        //     if (i === 1) { // Apply the curve to the FIRST longitudinal road (i=1)
        //         // 1. Define the points for the curved path
        //         const straightEnd = CURVE_START_Z;

        //         const startPoint = new THREE.Vector3(x, 0.1, 0);
        //         const straightEnd_Point = new THREE.Vector3(x, 0.1, straightEnd);

        //         // Define the center and angle for the arc
        //         const centerPoint = new THREE.Vector3(x, 0.1, straightEnd + CURVE_RADIUS);

        //         // Start of the curve (straight up)
        //         const curveStart = new THREE.Vector3(x, 0.1, straightEnd);
        //         // End of the curve (after 100 degrees rotation around the center)
        //         const angleInRadians = THREE.MathUtils.degToRad(120);

        //         // Calculate the end point of the 100 degree arc
        //         const endX = centerPoint.x + CURVE_RADIUS * Math.sin(angleInRadians);
        //         const endZ = centerPoint.z - CURVE_RADIUS * Math.cos(angleInRadians);
        //         const curveEnd = new THREE.Vector3(endX, 0.1, endZ);

        //         // 2. Create the path using a combination of straight lines and an arc
        //         const path = new THREE.CurvePath();

        //         // Part 1: Straight road section
        //         // A straight line is simply a LineCurve from start to end
        //         const straightPath = new THREE.LineCurve3(startPoint, straightEnd_Point);
        //         path.add(straightPath);

        //         // Part 2: 100-degree Arc at the end
        //         // Use an ArcCurve for the bend
        //         const arcPath = new THREE.ArcCurve(
        //             centerPoint.x, // x center
        //             centerPoint.z, // y center (z-axis in 3D)
        //             CURVE_RADIUS,  // radius
        //             THREE.MathUtils.degToRad(270), // start angle (270deg = straight up, if rotated around Z axis)
        //             THREE.MathUtils.degToRad(270 + 100), // end angle (270 + 100 = 370 or 10deg)
        //             false // Clockwise direction
        //         );

        //         // Since ArcCurve is 2D, we need a custom function or more complex path construction for a proper 3D road that starts at straightEnd_Point.

        //         // --- SIMPLER APPROACH USING SplineCurve for easy bending ---
        //         // Let's use a simpler, more common Three.js approach for curved roads: THREE.CatmullRomCurve3, which is good for smooth paths.

        //         const curvePoints = [
        //             new THREE.Vector3(x, 0.1, 0),                        // Start
        //             new THREE.Vector3(x, 0.1, straightEnd - 100),        // Control Point 1 (Straight)
        //             new THREE.Vector3(x, 0.1, straightEnd),              // Start of Curve
        //             new THREE.Vector3(x + 100, 0.1, straightEnd + 100),  // Mid-Curve Control Point
        //             new THREE.Vector3(x + 200, 0.1, straightEnd + 200)   // End Point (approximately 100 degrees turn)
        //         ];

        //         const curve = new THREE.CatmullRomCurve3(curvePoints);

        //         // 3. Generate TubeGeometry along the curve
        //         const roadGeometry = new THREE.TubeGeometry(
        //             curve,                 // path
        //             250,                   // segments (how smooth the path is)
        //             ROAD_WIDTH / 2,        // radius of the road profile
        //             6,                     // radial segments (how rounded the road side is)
        //             false                  // closed (false for open road)
        //         );

        //         road = new THREE.Mesh(roadGeometry, roadMaterial);

        //         // The position is already defined by the curve points, so we don't set a position here.

        //     } else {
        //         // All other longitudinal roads remain straight boxes
        //         const roadGeometry = new THREE.BoxGeometry(ROAD_WIDTH, 0.1, MAP_LENGTH);
        //         road = new THREE.Mesh(roadGeometry, roadMaterial);
        //         road.position.set(x, 0.1, MAP_LENGTH / 2);
        //     }

        //     road.receiveShadow = false;
        //     mapGroup.add(road);
        // }

        // // --- Transverse Roads (Horizontal - Z=constant, X=variable) ---
        // // (These remain unchanged, as they are not the road you wanted to curve)
        // const transRoads = 6;
        // const Z_START = 500;
        // const Z_END = MAP_LENGTH * 0.6; // 2800 * 0.6 = 1680
        // const transLength = Z_END - Z_START;
        // const transSpacing = transLength / (transRoads + 1);
        // transverseZ = []; // Clear array before population

        // for (let i = 1; i <= transRoads; i++) {
        //     const z = Z_START + transSpacing * i;
        //     transverseZ.push(z);
        //     const roadGeometry = new THREE.BoxGeometry(MAP_WIDTH, 0.1, ROAD_WIDTH);
        //     const road = new THREE.Mesh(roadGeometry, roadMaterial);
        //     road.position.set(MAP_WIDTH / 2, 0.1, z);
        //     road.receiveShadow = true;
        //     mapGroup.add(road);
        // }
        // }
        /**
         * Creates additional amenities like sports fields and the main highway.
         */
        function createAmenitiesAndRoads() {
            const fieldMaterial = new THREE.MeshLambertMaterial({ color: 0x388E3C });
            const amenityMaterial = new THREE.MeshLambertMaterial({ color: 0x9E9E9E });
            const highwayMaterial = new THREE.MeshLambertMaterial({ color: 0x212121 });

            // 1. Sports Fields (Bottom Middle) - placed in empty grid blocks
            const fieldSize = 100;
            const longRoads = 5;
            const longSpacing = MAP_WIDTH / (longRoads + 1);
            const blockOneXEnd = longSpacing;

            // Field 1: First X block (0 to ~267), low Z area (~50 to 500)
            const field1 = new THREE.Mesh(
                new THREE.BoxGeometry(fieldSize, 1, fieldSize * 2),
                fieldMaterial
            );
            field1.position.set(blockOneXEnd / 2, 0.5, 300);
            field1.receiveShadow = true;
            mapGroup.add(field1);

            // Field 2: Third X block (around the third road's center)
            // Center of the 3rd X block (between road 2 and road 3)
            const field2XCenter = (longitudinalX[1] + longitudinalX[2]) / 2;
            const field2 = new THREE.Mesh(
                new THREE.BoxGeometry(fieldSize, 1, fieldSize * 2),
                fieldMaterial
            );
            field2.position.set(field2XCenter, 0.5, 300);
            field2.receiveShadow = true;
            mapGroup.add(field2);

            // 2. Main Highway (Bottom)
            const highwayGeometry = new THREE.BoxGeometry(MAP_WIDTH + 600, 0.5, 100);
            const highway = new THREE.Mesh(highwayGeometry, highwayMaterial);
            highway.position.set(MAP_WIDTH / 2, 0.25, -50);
            highway.receiveShadow = true;
            mapGroup.add(highway);

            // 3. Main Entrance Gate Area (Bottom Center)
            const gateGeometry = new THREE.BoxGeometry(100, 25, 20);
            const gate = new THREE.Mesh(gateGeometry, amenityMaterial);
            gate.position.set(MAP_WIDTH / 2, 12.5, 0);
            gate.castShadow = true;
            mapGroup.add(gate);
        }

        /**
         * Populates the grid blocks defined by roads with houses.
         * Houses are placed in blocks between Z=50 (above highway) and Z=2000 (below residential spine).
         * Areas reserved for amenities are skipped.
         */
        /**
         * Helper to calculate grid coordinates for house placement.
         */
        function calculateGridCoordinates() {
            // Define X boundaries: map edges and longitudinal roads
            const allXPositions = [0, ...longitudinalX, MAP_WIDTH];

            // Define Z boundaries
            const Z_MIN_LAND = 50;
            const Z_AMENITY_CUTOFF = 500;
            const Z_MAX_GRID_FILL = 2000;

            // Filter transverseZ
            const filteredTransverseZ = transverseZ.filter(z => z < Z_MAX_GRID_FILL && z > Z_MIN_LAND);

            // Rebuild allZPositions to ensure proper block segmentation
            let allZPositions = [Z_MIN_LAND, ...filteredTransverseZ, Z_MAX_GRID_FILL];
            if (!filteredTransverseZ.some(z => Math.abs(z - Z_AMENITY_CUTOFF) < 5)) {
                allZPositions.push(Z_AMENITY_CUTOFF);
            }
            allZPositions.sort((a, b) => a - b);

            return { allXPositions, allZPositions, filteredTransverseZ, Z_MIN_LAND, Z_AMENITY_CUTOFF, Z_MAX_GRID_FILL };
        }

        /**
         * Create Line 1 (Right-most Strip) - CLUSTER BLOCK
         * Configured for "Cluster 8-10" logic (Rows 7+)
         */
        /**
         * Create Line 1 (Right-most Strip) - CUSTOM LOGIC
         * - Block C (Bottom): 40 houses + 12 houses (Red Road)
         * - Cluster 8: 15 pairs
         * - Cluster 9: 16 pairs
         * - Cluster 10: 16 pairs
         */
        /**
         * Create Line 1 (Right-most Strip) - CUSTOM LOGIC
         * - Block C (Bottom): 40 houses + 12 houses (Red Road)
         * - Cluster 8: 15 pairs
         * - Cluster 9: 16 pairs
         * - Cluster 10: 16 pairs
         * 
         * Layout optimization: 
        /**
         * Total pairs = 20 (C) + 15 (8) + 16 (9) + 16 (10) = 67 pairs.
         * To fit in ~2400 Z-space (150 to 2550), Pitch must be < 35.
         * Using Width=28 (Along Road), Gap=4 -> Pitch=32.
         * Total Z = 67 * 32 = 2144 + Gaps for roads. Fits well.
         */
        /**
         * Create Line 1 (Right-most Strip) - CUSTOM DUPLEX LOGIC
         * - Layout from Image: Two columns (Odd Block Left, Even Block Right).
         * - Each Block has 2 Houses (A and B).
         * - Block C: 20 Blocks (40 houses).
         * - Cluster 8: 15 Blocks (30 houses).
         * - Cluster 9: 16 Blocks (32 houses).
         * - Cluster 10: 16 Blocks (32 houses).
         */
        /**
         * Create Line 1 (Right-most Strip) - HORIZONTAL CLUSTER LOGIC
         * - Based on Image: Clusters 8, 9, 10 are Horizontal Blocks stacked vertically.
         * - Each Cluster has 2 Rows of Units (Odd Top, Even Bottom).
         * - Houses face OUTWARDS towards the horizontal roads (P1B, P2B, P3B).
         * - Sequence (Bottom to Top Z): Block C -> 10 -> 9 -> 8.
         */
        /**
         * Create Line 1 (Right-most Strip) - TOP-DOWN Layout
         * - Starts from Gate Side (Top/Low Z) and builds Down (High Z).
         * - Sequence: Cluster 10 -> P1B -> Cluster 9 -> P2B -> Cluster 8 -> P3B -> Block C.
         * - Horizontal Rows. Odd/Even logic preserved.
         */
        /**
         * Create Line 1 (Right-most Strip) - TOP-DOWN Layout
         * - Starts from Gate Side (Top/Low Z) and builds Down (High Z).
         * - Sequence: Cluster 10 -> P1B -> Cluster 9 -> P2B -> Cluster 8 -> P3B -> Block C.
         */
        /**
         * Create Line 1 (Right-most Strip) - FINAL ADJUSTMENTS
         * - Spacing increased to prevent 1A-2A overlap.
         * - Left Side Road explicitly drawn/connected.
         * - Cluster Roads extend to left boundary.
         */
        /**
         * Create Line 1 (Right-most Strip) - BOUNDARY ROADS & CONNECTIONS
         * - Spacing increased to prevent 1A-2A overlap.
         * - Left Side Road (Divider with Line 2).
         * - Right Side Road (Map Edge).
         * - Cluster Roads connect Left to Right.
         */
        /**
         * Create Line 1 (Right-most Strip) - WIDER LAND & SHORTER ROADS
         * - Line 1 Width increased (starts earlier).
         * - Longitudinal Roads cut to half length.
         * - Clusters re-centered in wider space.
         */
        /**
         * Create Line 1 (Right-most Strip) - AUTO WIDTH & REALISTIC JOIN
         * - Auto Calculate Line 1 Width based on house total width.
         * - Horizontal Roads join Line 2's Left Road (approx 1250) to Line 1's Right Road (Map Edge).
         */
        function createLine1_Cluster() {
            // CONSTANTS from User Edits
            const HOUSE_WIDTH = 64;
            const HOUSE_DEPTH = 68;
            const UNIT_GAP = 66;
            const UNIT_WIDTH = (HOUSE_WIDTH * 2) + UNIT_GAP;
            const UNIT_X_SPACING = UNIT_WIDTH - 70;

            // AUTO WIDTH CALCULATION
            // Cluster is 8 units wide.
            const CLUSTER_HOUSES_TOTAL_WIDTH = 8 * UNIT_X_SPACING;
            // Add some buffer for the road/edge
            const LINE1_TOTAL_WIDTH = CLUSTER_HOUSES_TOTAL_WIDTH + 100;

            // Calculate Start X relative to Map Edge
            // Line 1 ends at MAP_WIDTH. So it starts at MAP_WIDTH - TOTAL_WIDTH.
            const X_MAX_LINE1 = MAP_WIDTH;
            const X_MIN_LINE1 = X_MAX_LINE1 - LINE1_TOTAL_WIDTH;

            const X_CENTER = X_MIN_LINE1 + (LINE1_TOTAL_WIDTH / 2);

            // Road Constants
            const HALF_LENGTH = MAP_LENGTH / 2;
            const LONG_ROAD_WIDTH = 25;
            const ROAD_COLOR = 0x515151;

            // 1. Right Side Road (Map Edge)
            const rightRoad = new THREE.Mesh(
                new THREE.BoxGeometry(LONG_ROAD_WIDTH, 0.12, HALF_LENGTH),
                // new THREE.MeshLambertMaterial({ color: ROAD_COLOR })
                new THREE.MeshBasicMaterial({
                    color: ROAD_COLOR,
                    polygonOffset: true,
                    polygonOffsetFactor: -1,
                    polygonOffsetUnits: -1
                })
            );
            rightRoad.position.set(X_MAX_LINE1 - LONG_ROAD_WIDTH / 2, 0.12, HALF_LENGTH / 2);
            mapGroup.add(rightRoad);

            // 2. Connecting Logic
            // User: "cluster road will be joint in line 1 and line 2 road"
            // We assume Line 2 is immediately to the LEFT of Line 1.
            // Let's connect from X_MIN_LINE1 (Line 1 Left / Line 2 Right boundary) to X_MAX_LINE1.
            // Wait, user previously said "join at line 2 left side road".
            // Line 2 Left likely sits around MAP_WIDTH / 4 * 2 (1250 in old scale, but MAP_WIDTH is big now).
            // Let's rely on a fixed "Line 2 Left" anchor or just extend leftwards significantly.
            // Given "auto width", effectively Line 2 ends where Line 1 begins.
            // We will draw the horizontal road from [Line 2 Left Road] to [Line 1 Right Road].
            // Assume Line 2 is roughly same width? Or just use a fixed "Center-Left" point.
            // Old "Line 2 Left" was colWidth * 2. 
            // new MAP_WIDTH = 4500. colWidth = 1125. colWidth * 2 = 2250.
            const X_LINE2_LEFT = (MAP_WIDTH / 8) * 6;

            const CLUSTER_ROAD_GAP = 180;
            const CLUSTER_INTERNAL_GAP = 60;
            const BLOCK_HEIGHT = (HOUSE_DEPTH * 1.2) + CLUSTER_INTERNAL_GAP;

            // Start Z position (Gate Side / Top)
            let currentZ = 250;

            // --- 1. CLUSTER 10 ---
            // Centered in the specific Line 1 Zone
            const c10Width = 8 * UNIT_X_SPACING;
            const xStart10 = X_CENTER - c10Width / 2;

            createHorizontalRow(xStart10, currentZ, 8, "10", 1, 2, "North");
            createHorizontalRow(xStart10, currentZ + HOUSE_DEPTH + CLUSTER_INTERNAL_GAP, 8, "10", 2, 2, "South");

            currentZ += BLOCK_HEIGHT;

            // ROAD P1B
            // Connects Line 2 Left (2250) -> Line 1 Right (4500 approx)
            createConnectingRoad(X_LINE2_LEFT, X_MAX_LINE1, currentZ + CLUSTER_ROAD_GAP / 2);
            currentZ += CLUSTER_ROAD_GAP;

            // --- 2. CLUSTER 9 ---
            const c9Width = 8 * UNIT_X_SPACING;
            const xStart9 = X_CENTER - c9Width / 2;

            createHorizontalRow(xStart9, currentZ, 8, "9", 1, 2, "North");
            createHorizontalRow(xStart9, currentZ + HOUSE_DEPTH + CLUSTER_INTERNAL_GAP, 8, "9", 2, 2, "South");

            currentZ += BLOCK_HEIGHT;

            // ROAD P2B
            createConnectingRoad(X_LINE2_LEFT, X_MAX_LINE1, currentZ + CLUSTER_ROAD_GAP / 2);
            currentZ += CLUSTER_ROAD_GAP;

            // --- 3. CLUSTER 8 ---
            const c8Width = 8 * UNIT_X_SPACING;
            const xStart8 = X_CENTER - c8Width / 2;

            createHorizontalRow(xStart8, currentZ, 8, "8", 1, 2, "North");
            createHorizontalRow(xStart8, currentZ + HOUSE_DEPTH + CLUSTER_INTERNAL_GAP, 7, "8", 2, 2, "South");

            // ROAD P3B (Bottom)
            // Added explicit road for consistency if desired, or skip if only separator needed.
            // Logic usually puts road *between* clusters. 
            // Previous code had P3B after Cluster 8.
            currentZ += BLOCK_HEIGHT;
            createConnectingRoad(X_LINE2_LEFT, X_MAX_LINE1, currentZ + CLUSTER_ROAD_GAP / 2);


            // --- Helpers ---
            function createHorizontalRow(startX, z, count, cluster, startIdx, step, facing) {
                const rotY = facing === "South" ? 0 : Math.PI;
                for (let i = 0; i < count; i++) {
                    const unitIdx = startIdx + (i * step);
                    const x = startX + i * UNIT_X_SPACING;
                    // A
                    const hA = createHouseModel(HOUSE_WIDTH / 2 - 2, HOUSE_DEPTH, `${cluster}-${unitIdx}A`);
                    hA.position.set(x, 0, z);
                    hA.rotation.y = rotY;
                    mapGroup.add(hA);
                    // B
                    const hB = createHouseModel(HOUSE_WIDTH / 2 - 2, HOUSE_DEPTH, `${cluster}-${unitIdx}B`);
                    hB.position.set(x + HOUSE_WIDTH / 2 + UNIT_GAP / 2 + 2, 0, z);
                    hB.rotation.y = rotY;
                    mapGroup.add(hB);
                }
            }

            function createConnectingRoad(xStart, xEnd, z) {
                const width = xEnd - xStart;
                const centerX = xStart + width / 2;
                const road = new THREE.Mesh(
                    new THREE.BoxGeometry(width, 0.12, 40),
                    new THREE.MeshBasicMaterial({
                        color: 0x515151,
                        polygonOffset: true,
                        polygonOffsetFactor: -1,
                        polygonOffsetUnits: -1
                    })
                );
                road.position.set(centerX, 0.12, z);
                mapGroup.add(road);
            }
        }

        /**
         * Create Line 2 (Center-Right Strip) - CLUSTER BLOCK
         * Configured for "Cluster 1-7" logic (Rows 0-6)
         * NOTE: Contains Field 2 (Block 2)
         */
        /**
         * Create Line 2 (Center-Right Strip) - CLUSTERS 1-7
         * - Matches Line 1 Style (Auto Width, House Size, Roads).
         * - Sequence: Cluster 7 (Top) -> ... -> Cluster 1 (Bottom).
         */
        function createLine2_Cluster() {
            // CONSTANTS (MATCHING LINE 1)
            const HOUSE_WIDTH = 64;
            const HOUSE_DEPTH = 68;
            const UNIT_GAP = 66;
            const UNIT_WIDTH = (HOUSE_WIDTH * 2) + UNIT_GAP;
            const UNIT_X_SPACING = UNIT_WIDTH - 70;

            // AUTO WIDTH CALCULATION
            const CLUSTER_HOUSES_TOTAL_WIDTH = 8 * UNIT_X_SPACING;
            const LINE_TOTAL_WIDTH = CLUSTER_HOUSES_TOTAL_WIDTH + 100;

            // X Positioning
            // Line 1 Start was: MAP_WIDTH - LINE1_WIDTH.
            // Line 2 ends where Line 1 starts.
            const X_MAX_LINE2 = MAP_WIDTH - LINE_TOTAL_WIDTH;
            const X_MIN_LINE2 = X_MAX_LINE2 - LINE_TOTAL_WIDTH;
            const X_CENTER = X_MIN_LINE2 + (LINE_TOTAL_WIDTH / 2);

            // Connects Line 3 Left (approx) to Line 2 Right (Line 1 Left).
            // Line 3 Left roughly at MAP_WIDTH/8 * 2 ?
            // Let's us a dynamic calc:
            const X_LINE3_LEFT = (MAP_WIDTH / 8) * 2;

            const CLUSTER_ROAD_GAP = 180;
            const CLUSTER_INTERNAL_GAP = 60;
            const BLOCK_HEIGHT = (HOUSE_DEPTH * 1.2) + CLUSTER_INTERNAL_GAP;

            // Road Constants
            const LONG_ROAD_WIDTH = 25;
            const ROAD_COLOR = 0x333333;

            // Right Side Road (Line 2 Right Boundary) - Full Length
            const rightRoad = new THREE.Mesh(
                new THREE.BoxGeometry(LONG_ROAD_WIDTH, 0.12, MAP_LENGTH),
                new THREE.MeshLambertMaterial({ color: ROAD_COLOR })
            );
            rightRoad.position.set(X_MAX_LINE2 - LONG_ROAD_WIDTH / 2, 0.12, MAP_LENGTH / 2);
            mapGroup.add(rightRoad);

            // Start Z position (Gate Side / Top) - Match Line 1
            let currentZ = 250;

            // Loop 7 -> 1 (Top -> Bottom)
            const clusters = ["7", "6", "5", "4", "3", "2", "1"];

            clusters.forEach((clusterNum, index) => {
                // Determine Units count.
                // Line 1 clusters were 8 (16 houses).
                // "cluster will be 1-7". Assume standard 8-unit clusters.
                const unitsCount = 8;

                const cWidth = unitsCount * UNIT_X_SPACING;
                const xStart = X_CENTER - cWidth / 2;

                // Houses
                createHorizontalRow(xStart, currentZ, unitsCount, clusterNum, 1, 2, "North");
                createHorizontalRow(xStart, currentZ + HOUSE_DEPTH + CLUSTER_INTERNAL_GAP, unitsCount, clusterNum, 2, 2, "South");

                currentZ += BLOCK_HEIGHT;

                // Road (Bottom of cluster)
                // Road starts from right side of Line 2 and fits cluster width
                createConnectingRoad(X_MAX_LINE2, cWidth, currentZ + CLUSTER_ROAD_GAP / 2);
                currentZ += CLUSTER_ROAD_GAP;
            });


            // --- Helpers ---
            function createHorizontalRow(startX, z, count, cluster, startIdx, step, facing) {
                const rotY = facing === "South" ? 0 : Math.PI;
                for (let i = 0; i < count; i++) {
                    const unitIdx = startIdx + (i * step);
                    const x = startX + i * UNIT_X_SPACING;
                    // A
                    const hA = createHouseModel(HOUSE_WIDTH / 2 - 2, HOUSE_DEPTH, `${cluster}-${unitIdx}A`);
                    hA.position.set(x, 0, z);
                    hA.rotation.y = rotY;
                    mapGroup.add(hA);
                    // B
                    const hB = createHouseModel(HOUSE_WIDTH / 2 - 2, HOUSE_DEPTH, `${cluster}-${unitIdx}B`);
                    hB.position.set(x + HOUSE_WIDTH / 2 + UNIT_GAP / 2 + 2, 0, z);
                    hB.rotation.y = rotY;
                    mapGroup.add(hB);
                }
            }

            function createConnectingRoad(xRightEdge, clusterWidth, z) {
                // Road starts from right edge and extends left by cluster width
                const roadStartX = xRightEdge - clusterWidth;
                const centerX = roadStartX + clusterWidth / 2;
                const road = new THREE.Mesh(
                    new THREE.BoxGeometry(clusterWidth + 140, 0.12, 40),
                    new THREE.MeshBasicMaterial({
                        color: 0x515151,
                        polygonOffset: true,
                        polygonOffsetFactor: -1,
                        polygonOffsetUnits: -1
                    })
                );
                road.position.set(centerX - 70, 0.12, z);
                mapGroup.add(road);
            }
        }

        /**
         * Create Line 3 (Center-Left Strip) - BUNCHES 1-6
         * - Matches Line 1 & 2 Style (Auto Width, House Size, Roads).
         * - Sequence: Bunch 6 (Top) -> ... -> Bunch 1 (Bottom).
         * - House counts: Bunch 1=36, Bunch 2=28, Bunch 3=28, Bunch 4=24, Bunch 5=28, Bunch 6=30
         */
        function createLine3_Bunch() {
            // CONSTANTS (MATCHING LINE 1 & 2)
            const HOUSE_WIDTH = 64;
            const HOUSE_DEPTH = 68;
            const UNIT_GAP = 66;
            const UNIT_WIDTH = (HOUSE_WIDTH * 2) + UNIT_GAP;
            const UNIT_X_SPACING = UNIT_WIDTH - 70;

            // Bunch specifications (houses per bunch)
            const bunchSpecs = [
                { name: "6", houses: 30, road: "P6A" },
                { name: "5", houses: 28, road: "P5A" },
                { name: "4", houses: 24, road: "P4A" },
                { name: "3", houses: 28, road: "P3A" },
                { name: "2", houses: 28, road: "P2A" },
                { name: "1", houses: 36, road: "P1A" }
            ];

            // Calculate max width needed (Bunch 1 has 36 houses = 18 units)
            const MAX_UNITS = 18; // 36 houses / 2
            const CLUSTER_HOUSES_TOTAL_WIDTH = MAX_UNITS * UNIT_X_SPACING;
            const LINE_TOTAL_WIDTH = CLUSTER_HOUSES_TOTAL_WIDTH + 100;

            // X Positioning
            // Line 3 ends where Line 2 starts (no gap)
            // Line 2 ends at: X_MIN_LINE2 = (MAP_WIDTH - LINE_TOTAL_WIDTH) - LINE_TOTAL_WIDTH
            const LINE2_WIDTH = -120; // Line 2's width (8 units)
            const X_MAX_LINE3 = MAP_WIDTH - LINE2_WIDTH - LINE_TOTAL_WIDTH;
            const X_MIN_LINE3 = X_MAX_LINE3 - LINE_TOTAL_WIDTH;
            const X_CENTER = X_MIN_LINE3 + (LINE_TOTAL_WIDTH / 2);

            // Connects Line 4 Left to Line 3 Right
            const X_LINE4_LEFT = 0; // Map edge

            const CLUSTER_ROAD_GAP = 180;
            const CLUSTER_INTERNAL_GAP = 60;
            const BLOCK_HEIGHT = (HOUSE_DEPTH * 1.2) + CLUSTER_INTERNAL_GAP;

            // Road Constants
            const LONG_ROAD_WIDTH = 45;
            const ROAD_COLOR = 0x333333;

            // Right Side Road (Line 3 Right Boundary) - Full Length
            const rightRoad = new THREE.Mesh(
                new THREE.BoxGeometry(LONG_ROAD_WIDTH, 0.012, MAP_LENGTH),
                new THREE.MeshBasicMaterial({
                    color: 0x515151,
                    polygonOffset: true,
                    polygonOffsetFactor: -1,
                    polygonOffsetUnits: -1
                })
            );
            rightRoad.position.set(X_MAX_LINE3 - LONG_ROAD_WIDTH / 2, 0.012, MAP_LENGTH / 2);
            mapGroup.add(rightRoad);

            // Start Z position (Gate Side / Top)
            let currentZ = 250;

            // Collect road endpoints for curved left road
            const roadEndpoints = [];

            // Loop through bunches (Top -> Bottom)
            bunchSpecs.forEach((bunch) => {
                const totalHouses = bunch.houses;
                const unitsCount = totalHouses / 2; // Each unit has 2 houses (A and B)

                const cWidth = unitsCount * UNIT_X_SPACING;
                // Position houses from right side (X_MAX_LINE3) extending left
                const xStart = X_MAX_LINE3 - cWidth;

                // Houses
                createHorizontalRow(xStart, currentZ, unitsCount, bunch.name, 1, 2, "North");
                createHorizontalRow(xStart, currentZ + HOUSE_DEPTH + CLUSTER_INTERNAL_GAP, unitsCount, bunch.name, 2, 2, "South");

                currentZ += BLOCK_HEIGHT;

                // Road (Bottom of bunch)
                const roadZ = currentZ + CLUSTER_ROAD_GAP / 2;
                createConnectingRoad(X_MAX_LINE3, cWidth, roadZ);

                // Store left endpoint for curved road
                const leftEndX = X_MAX_LINE3 - cWidth - 140; // Account for road extension
                roadEndpoints.push({ x: leftEndX, z: roadZ });

                currentZ += CLUSTER_ROAD_GAP;
            });

            // Create curved left road connecting all endpoints and extending to CHL end point
            if (roadEndpoints.length > 0) {
                // CHL end point coordinates (from createResidentialBlocks)
                const CHL_END_X = MAP_WIDTH - 100;
                const CHL_END_Z = MAP_LENGTH * 0.85;

                // Add start and end points for full coverage
                const curvePoints = [
                    new THREE.Vector3(roadEndpoints[0].x, 0.012, 0), // Start from top
                    ...roadEndpoints.map(ep => new THREE.Vector3(ep.x, 0.012, ep.z)),
                    new THREE.Vector3(roadEndpoints[roadEndpoints.length - 1].x, 0.012, roadEndpoints[roadEndpoints.length - 1].z + 200), // Transition point
                    new THREE.Vector3(CHL_END_X, 0.012, CHL_END_Z + 350) // Connect to CHL end point
                ];

                // Create smooth curve through all points
                const curve = new THREE.CatmullRomCurve3(curvePoints);

                // Generate tube geometry along the curve
                const tubeGeometry = new THREE.TubeGeometry(
                    curve,
                    500, // segments for smoothness
                    LONG_ROAD_WIDTH / 2, // radius
                    108, // radial segments
                    false // not closed
                );

                const curvedRoad = new THREE.Mesh(
                    tubeGeometry,
                    new THREE.MeshBasicMaterial({
                        color: 0x515151, polygonOffset: true,
                        polygonOffsetFactor: -1,
                        polygonOffsetUnits: -1
                    })
                );
                mapGroup.add(curvedRoad);
            }


            // --- Helpers ---
            function createHorizontalRow(startX, z, count, bunch, startIdx, step, facing) {
                const rotY = facing === "South" ? 0 : Math.PI;
                for (let i = 0; i < count; i++) {
                    const unitIdx = startIdx + (i * step);
                    const x = startX + i * UNIT_X_SPACING;
                    // A
                    const hA = createHouseModel(HOUSE_WIDTH / 2 - 2, HOUSE_DEPTH, `${bunch}-${unitIdx}A`);
                    hA.position.set(x, 0, z);
                    hA.rotation.y = rotY;
                    mapGroup.add(hA);
                    // B
                    const hB = createHouseModel(HOUSE_WIDTH / 2 - 2, HOUSE_DEPTH, `${bunch}-${unitIdx}B`);
                    hB.position.set(x + HOUSE_WIDTH / 2 + UNIT_GAP / 2 + 2, 0, z);
                    hB.rotation.y = rotY;
                    mapGroup.add(hB);
                }
            }

            function createConnectingRoad(xRightEdge, bunchWidth, z) {
                // Road starts from right edge and extends left by bunch width + extension
                const roadStartX = xRightEdge - bunchWidth;
                const centerX = roadStartX + bunchWidth / 2;
                const road = new THREE.Mesh(
                    new THREE.BoxGeometry(bunchWidth + 140, 0.12, 40),
                    new THREE.MeshBasicMaterial({
                        color: 0x515151,
                        polygonOffset: true,
                        polygonOffsetFactor: -1,
                        polygonOffsetUnits: -1
                    })
                );
                road.position.set(centerX - 70, 0.12, z);
                mapGroup.add(road);
            }
        }

        /**
         * Create Line 4 (Left-most Strip) - EMPTY BLOCK
         * Configured to be empty by default (House count override 0 or just logic disabled)
         */
        function createLine4_Empty() {
            const { allXPositions, allZPositions, filteredTransverseZ, Z_MIN_LAND, Z_AMENITY_CUTOFF, Z_MAX_GRID_FILL } = calculateGridCoordinates();
            const i = 0; // Left-most column index

            // Config - user wants this empty, but wants logic present to "set own amount".
            // We'll proceed with placing houses but set a "limit" or "enable" flag logic.
            // USER REQUEST: "line 4 will be empty"
            const ENABLE_LINE_4 = false; // Set to true to modify amount

            if (!ENABLE_LINE_4) return;

            // Config
            const HOUSE_WIDTH = 30;
            const HOUSE_LENGTH = 50;
            const HOUSE_X_SPACING = HOUSE_WIDTH + 30;
            const HOUSE_Z_SPACING = HOUSE_LENGTH + 40;

            const xStartRaw = allXPositions[i];
            const xEndRaw = allXPositions[i + 1];
            let xStart = xStartRaw + (i > 0 ? ROAD_WIDTH / 2 : 0);
            let xEnd = xEndRaw - (i < allXPositions.length - 2 ? ROAD_WIDTH / 2 : 0);

            if ((xEnd - xStart) <= HOUSE_WIDTH) return;

            for (let j = 0; j < allZPositions.length - 1; j++) {
                const zStartRaw = allZPositions[j];
                const zEndRaw = allZPositions[j + 1];

                // AMENITY EXCLUSION: Field 1 is here
                if (zStartRaw >= Z_MIN_LAND && zEndRaw <= Z_AMENITY_CUTOFF) continue;

                let zStart = zStartRaw + (filteredTransverseZ.includes(zStartRaw) ? ROAD_WIDTH / 2 : 0);
                let zEnd = zEndRaw - (filteredTransverseZ.includes(zEndRaw) ? ROAD_WIDTH / 2 : 0);

                if ((zEnd - zStart) <= HOUSE_LENGTH) continue;
                if (zStartRaw >= Z_MAX_GRID_FILL - 100) continue;

                // Place Houses
                const housesX = Math.floor((xEnd - xStart) / HOUSE_X_SPACING);
                const housesZ = Math.floor((zEnd - zStart) / HOUSE_Z_SPACING);

                if (housesX < 1 || housesZ < 1) continue;

                const blockCenterX = (xStart + xEnd) / 2;
                const blockCenterZ = (zStart + zEnd) / 2;
                const startOffsetX = -((housesX - 1) * HOUSE_X_SPACING) / 2;
                const startOffsetZ = -((housesZ - 1) * HOUSE_Z_SPACING) / 2;

                let houseCounter = 1;
                for (let x = 0; x < housesX; x++) {
                    for (let z = 0; z < housesZ; z++) {
                        const houseID = `L4-C${j}-${houseCounter++}`;
                        const house = createHouseModel(HOUSE_WIDTH, HOUSE_LENGTH, houseID);
                        const hX = blockCenterX + startOffsetX + x * HOUSE_X_SPACING;
                        const hZ = blockCenterZ + startOffsetZ + z * HOUSE_Z_SPACING;
                        house.position.set(hX, 0, hZ);
                        mapGroup.add(house);
                    }
                }
            }
        }

        /**
         * Handles window resizing.
         */
        function onWindowResize() {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        /**
         * Handle mouse click/tap event for Raycasting
         */
        function onPointerDown(event) {
            // Calculate mouse position in normalized device coordinates
            // (-1 to +1) for both components
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Update the raycaster with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);

            // Calculate objects intersecting the picking ray
            // Intersect recursively with mapGroup children
            const intersects = raycaster.intersectObjects(mapGroup.children, true);

            if (intersects.length > 0) {
                // Get the first intersected object (closest to camera)
                let intersect = intersects[0];
                let obj = intersect.object;

                // Traverse up to find if we clicked a house group or a house part
                if (obj.userData.isHousePart || (obj.parent && obj.parent.userData.isHouse)) {
                    // Find the main group
                    let houseGroup = null;

                    if (obj.parent && obj.parent.userData.isHouse) {
                        houseGroup = obj.parent;
                    } else if (obj.userData.isHousePart && obj.parent) {
                        houseGroup = obj.parent;
                    }

                    if (houseGroup) {
                        selectHouse(houseGroup);
                    }
                } else {
                    // Clicked something else (ground, road, etc.)
                    deselectHouse(); // Deselect if clicking on empty ground or non-house object
                }
            } else {
                // Clicked sky
                deselectHouse();
            }
        }

        function selectHouse(group) {
            // If selecting the same house, do nothing
            if (selectedHouse === group) return;

            // 1. Deselect previous
            deselectHouse();

            // 2. Select new
            selectedHouse = group;

            // 3. Highlight ALL parts of the house group
            group.children.forEach(child => {
                // Check if the child is a part of the house that should be highlighted
                // (e.g., body, roof, dormer, door, etc., but not plot lines or trees)
                if ((child.userData.isHousePart || child.userData.isHouseBody) && child.material) {
                    // Ensure original color is saved if not already (should be set in createHouseModel)
                    if (child.userData.originalColor === undefined) {
                        child.userData.originalColor = child.material.color.getHex();
                    }

                    // Use the status-specific color stored in the group
                    child.material.color.setHex(group.userData.statusColor || SELECTED_COLOR);
                }
            });

            // 4. Show Popup
            showPopup(group.userData);
        }

        function deselectHouse() {
            if (selectedHouse) {
                // Restore colors for all children of the previously selected house
                selectedHouse.children.forEach(child => {
                    if ((child.userData.isHousePart || child.userData.isHouseBody) && child.userData.originalColor !== undefined && child.material) {
                        child.material.color.setHex(child.userData.originalColor);
                    }
                });
                selectedHouse = null;
            }
            hidePopup();
        }

        let hideTimeout = null;

        function showPopup(data) {
            const popup = document.getElementById('house-popup');
            const title = document.getElementById('popup-title');
            const idLabel = document.getElementById('popup-id');
            const statusLabel = document.getElementById('popup-status');

            // Clear any pending hide timeout to prevent accidental closing
            if (hideTimeout) {
                clearTimeout(hideTimeout);
                hideTimeout = null;
            }

            // Read data from the house object
            // data contains { id, status, statusColor, ... }
            const status = data.status || 'Available';
            const colorHex = data.statusColor ? '#' + data.statusColor.toString(16).padStart(6, '0') : '#000000';

            title.innerText = `House ${data.id}`;
            idLabel.innerText = `ID: #${data.id}`;
            statusLabel.innerText = status;

            // Set status text color to match the status highlight
            statusLabel.style.color = colorHex;
            statusLabel.className = "text-lg font-bold uppercase";

            // Show
            popup.classList.remove('hidden');
            // Small timeout to allow display:block to apply before transition
            setTimeout(() => {
                popup.classList.remove('translate-x-full');
            }, 10);
        }

        function hidePopup() {
            const popup = document.getElementById('house-popup');
            popup.classList.add('translate-x-full');

            // Clear existing timeout if any
            if (hideTimeout) {
                clearTimeout(hideTimeout);
            }

            // Wait for transition to finish before hiding
            hideTimeout = setTimeout(() => {
                popup.classList.add('hidden');
                hideTimeout = null;
            }, 300);
        }
        function animate() {
            // Only continue the loop if the renderer exists
            if (!renderer) return;

            requestAnimationFrame(animate);

            // Update controls only if they exist
            if (controls) {
                controls.update(); // Update controls in the loop
            }

            renderer.render(scene, camera);
        }

        // --- Start the application on window load ---
        window.onload = function () {

            init();

            // If init() succeeded, hide the overlay. If it failed, the error handler updated the overlay.
            if (renderer) {
                document.getElementById('loading-overlay').classList.add('hidden');
            }
        };

    </script>

</body>

</html>