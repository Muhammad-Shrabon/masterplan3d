<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

</head>

<body>




    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Load OrbitControls (Requires THREE global object) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        let scene, camera, renderer, controls, flagObj, lakeObj, river;

        // --- Fog Reveal Animation Variables ---
        let fogRevealStartTime = null;
        let fogRevealDuration = 8000; // 8 seconds for smoother, more realistic reveal
        let initialFogDensity = 0.18; // Very dense fog
        let finalFogDensity = 0.0005; // Clear visibility (matches existing fog)
        let fogRevealComplete = false;
        let initialCameraY = null; // Store initial camera Y position

        class CartoonRiver {
            constructor(scene, config) {
                this.scene = scene;
                this.points = config.points || [];
                this.width = config.width || 10;
                this.thickness = config.thickness || 0.8;
                this.color = config.color || 0x33ccff;

                // New position and rotation configuration
                this.position = config.position || { x: 0, y: 0.2, z: 0 };
                this.rotation = config.rotation || { x: 0, y: 0, z: 0 };

                this.mesh = null;
                this.material = null;

                this.init();
            }

            init() {
                // Create the smooth curve path
                const curve = new THREE.CatmullRomCurve3(this.points);
                curve.curveType = 'catmullrom';
                curve.tension = 0.5;

                // Tube radius is half the width
                const radius = this.width / 2;

                // Create the geometry
                const tubeGeo = new THREE.TubeGeometry(curve, 100, radius, 8, false);

                // Apply thickness by scaling the Y axis
                const yScale = this.thickness / this.width;
                tubeGeo.scale(1, yScale, 1);

                this.material = new THREE.MeshPhongMaterial({
                    color: this.color,
                    transparent: true,
                    opacity: 0.9,
                    shininess: 120
                });

                this.mesh = new THREE.Mesh(tubeGeo, this.material);
                this.mesh.receiveShadow = true;

                // Apply coordinates and rotation
                this.mesh.position.set(this.position.x, this.position.y, this.position.z);
                this.mesh.rotation.set(this.rotation.x, this.rotation.y, this.rotation.z);

                if (this.scene) this.scene.add(this.mesh);
            }

            update(time) {
                if (this.material) {
                    // Gentle pulse effect for water movement
                    this.material.opacity = 0.85 + Math.sin(time * 0.0015) * 0.05;
                }
            }
        }
        // Configuration from road.html
        const ROAD_CONFIGS = [
            // Lake Near Road
            {
                width: 10,
                points: [
                    new THREE.Vector3(300, 0, 100),
                    new THREE.Vector3(300, 0, 0),
                    new THREE.Vector3(100, 0, 0),
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, 0, -800),
                    new THREE.Vector3(-100, 0, -980),
                ],
                segments: 2000,
                position: { x: -550, y: 0, z: -200 },
                rotation: { x: 0, y: 11, z: 0 }
            },
            // River Near Road
            {
                width: 10,
                points: [
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, 0, -1200)
                ],
                segments: 2000,
                position: { x: 266, y: 0, z: 330 },
                rotation: { x: 0, y: 0, z: 0 }
            },
            // BIG Road
            {
                width: 10,
                points: [
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, 0, -1200)
                ],
                segments: 2000,
                position: { x: -34, y: 0, z: 428 },
                rotation: { x: 0, y: 0, z: 0 }
            },
            {
                width: 10,
                points: [
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, 0, -1000),
                    // new THREE.Vector3(0, 0, -1150),
                    new THREE.Vector3(0, 0, -2050),
                    new THREE.Vector3(0, 0, -2050),
                    new THREE.Vector3(1400, 0, -1900),
                    new THREE.Vector3(1200, 0, -1250),
                    new THREE.Vector3(1000, 0, -800),
                    new THREE.Vector3(1050, 0, -500),
                    new THREE.Vector3(1000, 0, -200),
                    new THREE.Vector3(1000, 0, 0),
                    // new THREE.Vector3(1200, 0, -2150),
                    // new THREE.Vector3(1200, 0, -550),
                    // new THREE.Vector3(1200, 0, 0),
                    // new THREE.Vector3(1200, 0, -650),
                ],
                segments: 2000,
                position: { x: -334, y: 0, z: 427 },
                rotation: { x: 0, y: 0, z: 0 }
            },
            {
                width: 10,
                points: [
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, 0, -500)
                ],
                segments: 2000,
                position: { x: -634, y: 0, z: 328 },
                rotation: { x: 0, y: 0, z: 0 }
            },
            // Small Road to connect House
            // BUnch Road (1 - 6)
            {
                width: 4,
                points: [
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, 0, 292)
                ],
                segments: 2000,
                position: { x: -30, y: 0, z: -3 },
                rotation: { x: 0, y: -11, z: 0 }
            },
            {
                width: 4,
                points: [
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, 0, 292)
                ],
                segments: 2000,
                position: { x: -30, y: 0, z: 50 },
                rotation: { x: 0, y: -11, z: 0 }
            },
            {
                width: 4,
                points: [
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, 0, 292)
                ],
                segments: 2000,
                position: { x: -30, y: 0, z: 105 },
                rotation: { x: 0, y: -11, z: 0 },
            },
            {
                width: 4,
                points: [
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, 0, 292)
                ],
                segments: 2000,
                position: { x: -30, y: 0, z: 160 },
                rotation: { x: 0, y: -11, z: 0 },
            },
            {
                width: 4,
                points: [
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, 0, 292)
                ],
                segments: 2000,
                position: { x: -30, y: 0, z: 215 },
                rotation: { x: 0, y: -11, z: 0 },
            },
            {
                width: 4,
                points: [
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, 0, 292)
                ],
                segments: 2000,
                position: { x: -30, y: 0, z: 270 },
                rotation: { x: 0, y: -11, z: 0 },
            },
            // Cluster Road Start - (1-7)
            {
                width: 4,
                points: [
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, 0, 292)
                ],
                segments: 2000,
                position: { x: -330, y: 0, z: -3 },
                rotation: { x: 0, y: -11, z: 0 }
            },
            {
                width: 4,
                points: [
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, 0, 292)
                ],
                segments: 2000,
                position: { x: -330, y: 0, z: 45 },
                rotation: { x: 0, y: -11, z: 0 }
            },
            {
                width: 4,
                points: [
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, 0, 292)
                ],
                segments: 2000,
                position: { x: -330, y: 0, z: 95 },
                rotation: { x: 0, y: -11, z: 0 },
            },
            {
                width: 4,
                points: [
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, 0, 292)
                ],
                segments: 2000,
                position: { x: -330, y: 0, z: 140 },
                rotation: { x: 0, y: -11, z: 0 },
            },
            {
                width: 4,
                points: [
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, 0, 292)
                ],
                segments: 2000,
                position: { x: -330, y: 0, z: 185 },
                rotation: { x: 0, y: -11, z: 0 },
            },
            {
                width: 4,
                points: [
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, 0, 292)
                ],
                segments: 2000,
                position: { x: -330, y: 0, z: 229 },
                rotation: { x: 0, y: -11, z: 0 },
            },
            {
                width: 4,
                points: [
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, 0, 292)
                ],
                segments: 2000,
                position: { x: -330, y: 0, z: 275 },
                rotation: { x: 0, y: -11, z: 0 },
            },
            {
                width: 4,
                points: [
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, 0, 897)
                ],
                segments: 2000,
                position: { x: -630, y: 0, z: 324 },
                rotation: { x: 0, y: -11, z: 0 },
            },
            // Cluster road 8-10
            {
                width: 4,
                points: [
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, 0, 292)
                ],
                segments: 2000,
                position: { x: -630, y: 0, z: 182 },
                rotation: { x: 0, y: -11, z: 0 },
            },
            {
                width: 4,
                points: [
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, 0, 292)
                ],
                segments: 2000,
                position: { x: -630, y: 0, z: 229 },
                rotation: { x: 0, y: -11, z: 0 },
            },
            {
                width: 4,
                points: [
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, 0, 292)
                ],
                segments: 2000,
                position: { x: -630, y: 0, z: 275 },
                rotation: { x: 0, y: -11, z: 0 },
            },
            // Empty Land Road
            {
                width: 4,
                points: [
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, 0, 292)
                ],
                segments: 2000,
                position: { x: -330, y: 0, z: 375 },
                rotation: { x: 0, y: -11, z: 0 },
            },
            {
                width: 4,
                points: [
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, 0, 292)
                ],
                segments: 2000,
                position: { x: -330, y: 0, z: 425 },
                rotation: { x: 0, y: -11, z: 0 },
            },
            {
                width: 4,
                points: [
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, 0, 100)
                ],
                segments: 2000,
                position: { x: -175, y: 0, z: 328 },
                rotation: { x: 0, y: 0, z: 0 },
            },
        ];

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            flagObj = createFlag(scene, { x: 10, y: 0, z: -5 });
            // scene.fog = new THREE.Fog( 0xcccccc, 10, 15 );
            // Initialize with dense fog for reveal animation
            scene.fog = new THREE.FogExp2(0x87ceeb, initialFogDensity);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 14000);

            camera.position.z = 668;
            camera.position.y = -98;
            camera.position.x = -178;
            camera.lookAt(1000, 100, 1000);

            scene.add(camera)

            // Lighting for MeshStandardMaterial
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 150, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.bias = -0.0005; // Reduces shadow acne (blinking shadows)
            directionalLight.shadow.normalBias = 0.05; // Helps with shadow artifacts on surfaces
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);


            renderer = new THREE.WebGLRenderer({
                antialias: true,
                logarithmicDepthBuffer: true // Prevents flickering at far distances/large scales
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true; // Enable shadows
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Smoother shadows
            // Removed ACESFilmicToneMapping and sRGBEncoding to restore original color vibrancy
            document.body.appendChild(renderer.domElement)

            // Grid Helper
            // const grid = new THREE.GridHelper(1510, 80, 0x697565, 0x697565);
            // scene.add(grid);

            // Orbit Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.rotateSpeed = 0.08; // Less rotation speed
            controls.zoomSpeed = 1.8;   // Less zoom speed
            controls.panSpeed = 0.8;    // Less panning speed
            controls.minDistance = 0.1;
            controls.maxDistance = 3000;
            controls.maxPolarAngle = Math.PI / 2.1;
            controls.screenSpacePanning = true;

            // Ground Land
            const ground = new THREE.PlaneGeometry(14000, 14000);
            const groundMaterial = new THREE.MeshBasicMaterial({
                color: 0x008000,
                side: THREE.DoubleSide,
                polygonOffset: true,
                polygonOffsetFactor: 10,
                polygonOffsetUnits: 10
            });
            const groundMesh = new THREE.Mesh(ground, groundMaterial);
            groundMesh.rotation.x = -Math.PI / 2;
            groundMesh.position.y = -0.1;
            scene.add(groundMesh);


            // 
            // lakeObj = createCustomRoad(scene, {
            //     points: [
            //         new THREE.Vector3(-260, 0, 300),
            //         new THREE.Vector3(-50, 0, 300),
            //         new THREE.Vector3(-10, 0, 50),
            //         new THREE.Vector3(-10, 0, 10),
            //         new THREE.Vector3(300, 0, 22),
            //         new THREE.Vector3(650, 0, 25),
            //         new THREE.Vector3(1050, 0, -555),
            //     ],
            //     width: 20,
            //     thickness: 0.8,
            //     style: 'lake',
            //     position: { x: -450, y: 10.1, z: -160 },
            //     rotation: { x: 0, y: 0, z: 0 },
            // });



            // LAKE START FROM HERE
            // INITIALIZE THE RIVER CLASS WITH CUSTOM PARAMETERS
            // RIVER SYSTEM - A large flowing river at the edge of the city
            // RIVER SYSTEM - Centered at the Flag (10, 0, -5) with a high-quality "Z" curve
            // const riverPathPoints = [
            //     new THREE.Vector3(-600, 0, 150),
            //     new THREE.Vector3(-150, 0, 150),
            //     new THREE.Vector3(150, 0, -150),
            //     new THREE.Vector3(600, 0, -150)
            // ];

            // river = new RiverSystem(scene, riverPathPoints, {
            //     color: 0x00ccff,
            //     width: 40,
            //     thickness: 0.05, // Very flat to match the land surface
            //     position: { x: 10, y: 0.4, z: -5 }, // Centered exactly at the Flag
            //     rotation: { x: 0, y: 0, z: 0 }
            // });



            // 2. Snake Shape Curved Road with Depth
            // Curve ROAD START
            // createCustomRoad(scene, {
            //     points: [
            //         new THREE.Vector3(-12, 0, -10),     // Junction (start)
            //         new THREE.Vector3(28, 0, -10),     // Straighten out at end
            //         // new THREE.Vector3(28, 0, -12),     // Straighten out at end
            //         new THREE.Vector3(64, 0, -70),
            //         new THREE.Vector3(104, 0, -82),
            //         new THREE.Vector3(154, 0, -60),
            //         // new THREE.Vector3(184, 0, -72), 
            //         new THREE.Vector3(224, 0, -62),
            //         new THREE.Vector3(294, 0, -52),
            //         // new THREE.Vector3(304, 0, -72), 
            //         new THREE.Vector3(344, 0, -48),
            //         new THREE.Vector3(484, 0, -112),
            //         // new THREE.Vector3(144, 0, -112),     // Straighten out at end
            //         // new THREE.Vector3(124, 0, -122),     // Straighten out at end
            //     ],
            //     width: 10,
            //     thickness: 0.21, // Matches previous road
            //     style: 'dashed',
            //     position: { x: 276, y: 0, z: 195 },
            //     rotation: { x: 0, y: -11, z: 0 },
            // });



            requestAnimationFrame(sceneRender);

            const cityBlocks = new THREE.Group();
            scene.add(cityBlocks);

            const cityLandGeometry = new THREE.PlaneGeometry(1400, 800);
            const cityLandMaterial = new THREE.MeshBasicMaterial({
                color: 0xc1d86c,
                polygonOffset: true,
                polygonOffsetFactor: 5,
                polygonOffsetUnits: 5
            });

            const cityLand = new THREE.Mesh(cityLandGeometry, cityLandMaterial);
            cityLand.rotation.x = -Math.PI / 2;
            cityLand.position.y = 0;
            cityLand.position.x = -50;
            cityLand.position.z = 100;

            cityBlocks.add(cityLand);


            const subGreenLand1 = new THREE.Group();
            subGreenLand1.position.set(-20, 0, 5);
            cityBlocks.add(subGreenLand1);

            const subGreenLand2 = new THREE.Group();
            subGreenLand2.position.set(-20, 0, 5);
            cityBlocks.add(subGreenLand2);

            const subGreenLand3 = new THREE.Group();
            subGreenLand3.position.set(-20, 0, 5);
            cityBlocks.add(subGreenLand3);

            const subGreenLand4 = new THREE.Group();
            subGreenLand4.position.set(-20, 0, 5);
            cityBlocks.add(subGreenLand4);

            const subGreenLand5 = new THREE.Group();
            subGreenLand5.position.set(-20, 0, 5);
            cityBlocks.add(subGreenLand5);

            const subGreenLand6 = new THREE.Group();
            subGreenLand6.position.set(-20, 0, 5);
            cityBlocks.add(subGreenLand6);


            // Cluster 1
            const subGreenLandCL1 = new THREE.Group();
            subGreenLandCL1.position.set(-320, 0, 80);
            cityBlocks.add(subGreenLandCL1);
            // Cluster 2
            const subGreenLandCL2 = new THREE.Group();
            subGreenLandCL2.position.set(-320, 0, 31);
            cityBlocks.add(subGreenLandCL2);
            // Cluster 3
            const subGreenLandCL3 = new THREE.Group();
            subGreenLandCL3.position.set(-320, 0, -12);
            cityBlocks.add(subGreenLandCL3);
            // Cluster 4
            const subGreenLandCL4 = new THREE.Group();
            subGreenLandCL4.position.set(-320, 0, -55);
            cityBlocks.add(subGreenLandCL4);
            // Cluster 5
            const subGreenLandCL5 = new THREE.Group();
            subGreenLandCL5.position.set(-320, 0, -102);
            cityBlocks.add(subGreenLandCL5);
            // Cluster 6
            const subGreenLandCL6 = new THREE.Group();
            subGreenLandCL6.position.set(-320, 0, -151);
            cityBlocks.add(subGreenLandCL6);
            // Cluster 7
            const subGreenLandCL7 = new THREE.Group();
            subGreenLandCL7.position.set(-320, 0, -199);
            cityBlocks.add(subGreenLandCL7);
            // Cluster 8
            const subGreenLandCL8 = new THREE.Group();
            subGreenLandCL8.position.set(-620, 0, -12);
            cityBlocks.add(subGreenLandCL8);
            // Cluster 9
            const subGreenLandCL9 = new THREE.Group();
            subGreenLandCL9.position.set(-620, 0, 31);
            cityBlocks.add(subGreenLandCL9);
            // Cluster 10
            const subGreenLandCL10 = new THREE.Group();
            subGreenLandCL10.position.set(-620, 0, 80);
            cityBlocks.add(subGreenLandCL10);


            // Multiple Bunch Calls with refined serial pairing
            createHouseBunch(subGreenLand6, {
                serialCount: 30, // Numbers 1 to 20, each with A/B
                startX: 0,
                startZ: 5,
                unitSpacing: 16,
                houseGap: 280,
                rowSpacing: 25,
                startId: 1,
                clusterName: "BUNCH-6"
            });
            createHouseBunch(subGreenLand5, {
                serialCount: 28, // Numbers 1 to 20, each with A/B
                startX: 0,
                startZ: 60,
                unitSpacing: 16,
                houseGap: 280,
                rowSpacing: 25,
                startId: 2,
                clusterName: "BUNCH-5"
            });
            createHouseBunch(subGreenLand4, {
                serialCount: 24, // Numbers 1 to 20, each with A/B
                startX: 0,
                startZ: 115,
                unitSpacing: 16,
                houseGap: 280,
                rowSpacing: 25,
                startId: 2,
                clusterName: "BUNCH-4"
            });
            createHouseBunch(subGreenLand3, {
                serialCount: 27, // Numbers 1 to 20, each with A/B
                startX: 0,
                startZ: 170,
                unitSpacing: 16,
                houseGap: 280,
                rowSpacing: 25,
                startId: 2,
                clusterName: "BUNCH-3"
            });
            createHouseBunch(subGreenLand2, {
                serialCount: 28, // Numbers 1 to 20, each with A/B
                startX: 0,
                startZ: 225,
                unitSpacing: 16,
                houseGap: 280,
                rowSpacing: 25,
                startId: 2,
                clusterName: "BUNCH-2"
            });
            createHouseBunch(subGreenLand1, {
                serialCount: 36,
                startX: 0,
                startZ: 280,
                unitSpacing: 16,
                houseGap: 280,
                rowSpacing: 25,
                startId: 2,
                clusterName: "BUNCH-1"
            });

            // CLUSTER 1
            createHouseCluster(subGreenLandCL1, {
                serialCount: 36,
                startX: 0,
                startZ: 210,
                unitSpacing: 16,
                houseGap: 280,
                rowSpacing: 21,
                startId: 2,
                clusterName: "CLUSTER-1"
            });
            // CLUSTER 2
            createHouseCluster(subGreenLandCL2, {
                serialCount: 36,
                startX: 0,
                startZ: 210,
                unitSpacing: 16,
                houseGap: 280,
                rowSpacing: 20,
                startId: 2,
                clusterName: "CLUSTER-2"
            });
            // CLUSTER 3
            createHouseCluster(subGreenLandCL3, {
                serialCount: 36,
                startX: 0,
                startZ: 210,
                unitSpacing: 16,
                houseGap: 280,
                rowSpacing: 20,
                startId: 2,
                clusterName: "CLUSTER-3"
            });
            // CLUSTER 4
            createHouseCluster(subGreenLandCL4, {
                serialCount: 36,
                startX: 0,
                startZ: 210,
                unitSpacing: 16,
                houseGap: 280,
                rowSpacing: 20,
                startId: 2,
                clusterName: "CLUSTER-4"
            });
            // CLUSTER 5
            createHouseCluster(subGreenLandCL5, {
                serialCount: 36,
                startX: 0,
                startZ: 210,
                unitSpacing: 16,
                houseGap: 280,
                rowSpacing: 20,
                startId: 2,
                clusterName: "CLUSTER-5"
            });
            // CLUSTER 6
            createHouseCluster(subGreenLandCL6, {
                serialCount: 36,
                startX: 0,
                startZ: 210,
                unitSpacing: 16,
                houseGap: 280,
                rowSpacing: 22,
                startId: 2,
                clusterName: "CLUSTER-6"
            });
            // CLUSTER 7
            createHouseCluster(subGreenLandCL7, {
                serialCount: 36,
                startX: 0,
                startZ: 210,
                unitSpacing: 16,
                houseGap: 280,
                rowSpacing: 22,
                startId: 2,
                clusterName: "CLUSTER-7"
            });
            // CLUSTER 8
            createHouseCluster(subGreenLandCL8, {
                serialCount: 36,
                startX: 0,
                startZ: 210,
                unitSpacing: 16,
                houseGap: 280,
                rowSpacing: 22,
                startId: 2,
                clusterName: "CLUSTER-8"
            });
            // CLUSTER 9
            createHouseCluster(subGreenLandCL9, {
                serialCount: 36,
                startX: 0,
                startZ: 210,
                unitSpacing: 16,
                houseGap: 280,
                rowSpacing: 22,
                startId: 2,
                clusterName: "CLUSTER-9"
            });
            // CLUSTER 10
            createHouseCluster(subGreenLandCL10, {
                serialCount: 36,
                startX: 0,
                startZ: 210,
                unitSpacing: 16,
                houseGap: 280,
                rowSpacing: 22,
                startId: 2,
                clusterName: "CLUSTER-10"
            });

            // createHouseBunch(subGreenLand2, {
            //     serialCount: 10, // Numbers 101 to 110, each with A/B
            //     startX: 0,
            //     startZ: 0,
            //     unitSpacing: 7,
            //     houseGap: 3,
            //     rowSpacing: 12,
            //     startId: 101,
            //     clusterName: "CLUSTER-7"
            // });
            const asphaltBaseMat = new THREE.MeshStandardMaterial({
                color: 0x222222,
                roughness: 0.9,
                polygonOffset: true,
                polygonOffsetFactor: 1,
                polygonOffsetUnits: 1
            });

            const markingsMat = new THREE.MeshStandardMaterial({
                map: createMarkingsTexture(),
                transparent: true,
                depthWrite: false,
                blending: THREE.NormalBlending,
                polygonOffset: true,
                polygonOffsetFactor: -2,
                polygonOffsetUnits: -2
            });

            ROAD_CONFIGS.forEach(config => {
                const curve = new THREE.CatmullRomCurve3(config.points);
                const roadGeo = createRoadGeometry(curve, config.width, config.segments);

                // Create a group for each road to handle position and rotation together
                const roadGroup = new THREE.Group();
                scene.add(roadGroup);

                const baseMesh = new THREE.Mesh(roadGeo, asphaltBaseMat);
                baseMesh.position.y = 0.05; // Lift up slightly to avoid Z-fighting with city land
                baseMesh.receiveShadow = true;
                roadGroup.add(baseMesh);

                const markingsMesh = new THREE.Mesh(roadGeo, markingsMat);
                markingsMesh.position.y = 0.06; // Slightly above baseMesh
                roadGroup.add(markingsMesh);

                // Apply Position if defined
                if (config.position) {
                    roadGroup.position.set(config.position.x || 0, config.position.y || 0, config.position.z || 0);
                }

                // Apply Rotation if defined
                if (config.rotation) {
                    roadGroup.rotation.set(config.rotation.x || 0, config.rotation.y || 0, config.rotation.z || 0);
                }

                // createCityBuildings(curve, config.width);
            });

            // --- Initialize Cartoon River ---
            const riverPoints = [
                // new THREE.Vector3(-100, 0, -60),
                new THREE.Vector3(-680, 0, 350),
                new THREE.Vector3(-480, 0, 330),
                new THREE.Vector3(-480, 0, 140),
                new THREE.Vector3(-340, 0, 40),
                new THREE.Vector3(0, 0, 40),
                new THREE.Vector3(100, 0, 40),
                new THREE.Vector3(200, 0, 40),
                new THREE.Vector3(400, 0, -240),
                new THREE.Vector3(600, 0, -540),
                new THREE.Vector3(1080, 0, -1400),
            ];

            river = new CartoonRiver(scene, {
                points: riverPoints,
                width: 20,
                thickness: 0.8,
                color: 0x33ccff,
                position: { x: 0, y: 0.2, z: -180 },
                rotation: { x: 0, y: 0, z: 0 }
            });

            requestAnimationFrame(sceneRender);
        }

        /**
         * Creates a custom road with 3D thickness using THREE.BufferGeometry
         * @param {THREE.Scene} scene - The scene to add the road to
         * @param {Object} options - { points: [], width: 4, thickness: 0.5, segments: 128, style: 'dashed' }
         */

        // Create strait road with depth
        function createCustomRoad(scene, options) {
            const {
                points = [],
                width = 4,
                thickness = 0.01,
                segments = 128,
                style = 'dashed',
                position = { x: 0, y: 0, z: 0 },
                rotation = { x: 0, y: 0, z: 0 },
                color = null // Custom base color
            } = options;

            if (points.length < 2) return null;

            const curve = new THREE.CatmullRomCurve3(points);
            const curvePoints = curve.getPoints(segments);
            const tangent = new THREE.Vector3();

            const vertices = [];
            const indices = [];
            const uvs = [];

            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const p = curvePoints[i];

                curve.getTangentAt(t, tangent);
                const normal = new THREE.Vector3(0, 1, 0);
                const binormal = new THREE.Vector3().crossVectors(tangent, normal).normalize();

                // Calculate 4 vertices per segment (Top-Left, Top-Right, Bottom-Left, Bottom-Right)
                const pTL = p.clone().add(binormal.clone().multiplyScalar(width / 2)).add(new THREE.Vector3(0, thickness, 0));
                const pTR = p.clone().add(binormal.clone().multiplyScalar(-width / 2)).add(new THREE.Vector3(0, thickness, 0));
                const pBL = p.clone().add(binormal.clone().multiplyScalar(width / 2));
                const pBR = p.clone().add(binormal.clone().multiplyScalar(-width / 2));

                // Push vertices: Top Face (0, 1), Left Side (2, 3), Right Side (4, 5)
                // We duplicate vertices to have sharp edges (different normals/UVs)

                // Top vertices
                vertices.push(pTL.x, pTL.y, pTL.z); // 0
                vertices.push(pTR.x, pTR.y, pTR.z); // 1
                uvs.push(0, t * (curve.getLength() / width));
                uvs.push(1, t * (curve.getLength() / width));

                // Left side vertices
                vertices.push(pTL.x, pTL.y, pTL.z); // 2
                vertices.push(pBL.x, pBL.y, pBL.z); // 3
                uvs.push(0, t * (curve.getLength() / thickness));
                uvs.push(0.1, t * (curve.getLength() / thickness)); // Using tiny bit of texture space for sides

                // Right side vertices
                vertices.push(pTR.x, pTR.y, pTR.z); // 4
                vertices.push(pBR.x, pBR.y, pBR.z); // 5
                uvs.push(0, t * (curve.getLength() / thickness));
                uvs.push(0.1, t * (curve.getLength() / thickness));

                if (i < segments) {
                    const base = i * 6;
                    // Top Face
                    indices.push(base, base + 6, base + 1);
                    indices.push(base + 1, base + 6, base + 7);
                    // Left Wall
                    indices.push(base + 2, base + 3, base + 8);
                    indices.push(base + 3, base + 9, base + 8);
                    // Right Wall
                    indices.push(base + 4, base + 10, base + 5);
                    indices.push(base + 5, base + 10, base + 11);
                }
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();

            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            if (style === 'lake') {
                // Water Base - Deep Ocean Blue
                const grad = ctx.createLinearGradient(0, 0, 0, 512);
                grad.addColorStop(0, '#002b4d');
                grad.addColorStop(0.5, '#005b96');
                grad.addColorStop(1, '#002b4d');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, 128, 512);

                // Animated ripples/foam look (texture side)
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.lineWidth = 1.5;
                for (let i = 0; i < 60; i++) {
                    ctx.beginPath();
                    const x = Math.random() * 128;
                    const y = Math.random() * 512;
                    const w = 5 + Math.random() * 20;
                    ctx.moveTo(x - w, y);
                    ctx.bezierCurveTo(x - w / 2, y + 5, x + w / 2, y - 5, x + w, y);
                    ctx.stroke();
                }
            } else {
                // Asphalt Base
                ctx.fillStyle = color || '#222222';
                ctx.fillRect(0, 0, 128, 512);

                // Sidebar color for side walls (using a small strip of the texture)
                ctx.fillStyle = '#444444';
                ctx.fillRect(0, 0, 15, 512);

                // Noise/Grit for road
                for (let i = 0; i < 2000; i++) {
                    const x = 15 + Math.random() * 113;
                    const y = Math.random() * 512;
                    const gray = 20 + Math.random() * 30;
                    ctx.fillStyle = `rgb(${gray},${gray},${gray})`;
                    ctx.fillRect(x, y, 1, 1);
                }
            }

            if (style !== 'lake') {
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 4;
                if (style === 'dashed') {
                    ctx.setLineDash([80, 100]);
                    ctx.beginPath(); ctx.moveTo(71, 0); ctx.lineTo(71, 512); ctx.stroke();
                } else if (style === 'double') {
                    ctx.beginPath();
                    ctx.moveTo(60, 0); ctx.lineTo(60, 512);
                    ctx.moveTo(68, 0); ctx.lineTo(68, 512);
                    ctx.stroke();
                } else if (style === 'solid') {
                    ctx.setLineDash([]);
                    ctx.beginPath(); ctx.moveTo(71, 0); ctx.lineTo(71, 512); ctx.stroke();
                }

                // Side Lines
                ctx.strokeStyle = 'rgba(255,255,255,1)';
                ctx.setLineDash([]);
                ctx.strokeRect(17, -10, 2, 532);
                ctx.strokeRect(124, -10, 2, 532);
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;

            const material = (style === 'lake') ?
                new THREE.MeshStandardMaterial({
                    map: texture,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.8,
                    roughness: 0.2,
                    metalness: 0.3
                }) :
                new THREE.MeshBasicMaterial({
                    map: texture,
                    side: THREE.DoubleSide
                });

            const roadMesh = new THREE.Mesh(geometry, material);

            // Apply Position
            if (position) {
                roadMesh.position.set(position.x || 0, position.y || 0, position.z || 0);
            }

            // Apply Rotation
            if (rotation) {
                roadMesh.rotation.set(rotation.x || 0, rotation.y || 0, rotation.z || 0);
            }

            scene.add(roadMesh);
            return roadMesh;
        }

        function sceneRender(time) {
            requestAnimationFrame(sceneRender);
            const t = time * 0.001;
            controls.update();
            flagObj.animateFlag(time);

            // --- Fog Reveal Animation ---
            if (!fogRevealComplete) {
                const currentTime = time;

                if (fogRevealStartTime === null) {
                    fogRevealStartTime = currentTime;
                    initialCameraY = camera.position.y; // Store initial Y position
                }

                const elapsed = currentTime - fogRevealStartTime;
                const progress = Math.min(elapsed / fogRevealDuration, 1.0);

                // Improved easing function for ultra-smooth transition (ease-in-out-cubic)
                const easedProgress = progress < 0.5
                    ? 4 * progress * progress * progress
                    : 1 - Math.pow(-2 * progress + 2, 3) / 2;

                // Interpolate fog density with smooth curve
                const currentDensity = initialFogDensity - (initialFogDensity - finalFogDensity) * easedProgress;
                scene.fog.density = currentDensity;

                // Subtle camera height adjustment for cinematic reveal (rises slightly as fog clears)
                const cameraLift = 20; // Subtle 20 unit lift
                camera.position.y = initialCameraY + (cameraLift * easedProgress);

                if (progress >= 1.0) {
                    fogRevealComplete = true;
                    console.log('City fog reveal animation complete!');
                }
            }

            // Update River animation

            // --- Lake Water Animation ---
            if (lakeObj) {
                // 1. Flowing Texture
                if (lakeObj.material.map) {
                    lakeObj.material.map.offset.y = -t * 0.08;
                    lakeObj.material.map.offset.x = Math.sin(t * 0.5) * 0.02;
                }

                // 2. Vertex Wave Effect
                const pos = lakeObj.geometry.attributes.position;
                for (let i = 0; i < pos.count; i++) {
                    const mod6 = i % 6;
                    // Indices 0, 1, 2, 4 are top vertices
                    if (mod6 !== 3 && mod6 !== 5) {
                        const px = pos.getX(i);
                        const pz = pos.getZ(i);
                        // Multi-octave wave simulation
                        const wave = Math.sin(px * 0.04 + t * 2.0) * 1.5 +
                            Math.cos(pz * 0.04 + t * 1.5) * 1.5 +
                            Math.sin((px + pz) * 0.02 + t * 0.8) * 2.0;
                        pos.setY(i, 0.8 + wave); // 0.8 is baseline thickness
                    }
                }
                pos.needsUpdate = true;
                // Optional: compute normals for better lighting on waves
                // lakeObj.geometry.computeVertexNormals(); 
            }

            // Update River animation
            if (river) river.update(time);

            renderer.render(scene, camera)
        }


        // function createSquareGrid(size = 120, divisions = 80) {
        //     const vertices = [];
        //     const step = size / divisions;
        //     const half = size / 2;

        //     for (let i = 0; i <= divisions; i++) {
        //         const k = -half + i * step;

        //         // Vertical line
        //         vertices.push(-half, 0, k, half, 0, k);
        //         // Horizontal line
        //         vertices.push(k, 0, -half, k, 0, half);
        //     }

        //     const geometry = new THREE.BufferGeometry();
        //     geometry.setAttribute(
        //         'position',
        //         new THREE.Float32BufferAttribute(vertices, 3)
        //     );

        //     const material = new THREE.LineBasicMaterial({ color: 0x697565 });
        //     return new THREE.LineSegments(geometry, material);
        // }



        // Center Flag
        function createFlag(scene, position = { x: 0, y: 0, z: 0 }) {
            const group = new THREE.Group();

            /* =========================
               Flag Pole
            ========================= */
            const poleGeometry = new THREE.CylinderGeometry(0.1, 0.1, 10, 16);
            const poleMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);

            pole.position.set(0, 5, 0);
            group.add(pole);

            /* =========================
               Create Text Canvas
            ========================= */
            const canvas = document.createElement("canvas");
            canvas.width = 1024;
            canvas.height = 512;

            const ctx = canvas.getContext("2d");

            // Background
            ctx.fillStyle = "#ffffff"; // Bangladesh green
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Text
            ctx.font = "bold 80px Arial";
            ctx.fillStyle = "#ffffff";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("Bangla Bosoti Square", canvas.width / 2, canvas.height / 2);

            const flagTexture = new THREE.CanvasTexture(canvas);

            /* =========================
               Flag Cloth
            ========================= */
            const flagGeometry = new THREE.PlaneGeometry(6, 3, 20, 10);
            const flagMaterial = new THREE.MeshBasicMaterial({
                map: flagTexture,
                side: THREE.DoubleSide
            });

            const flag = new THREE.Mesh(flagGeometry, flagMaterial);
            flag.position.set(3, 7.5, 0);
            group.add(flag);

            /* =========================
               Position Group
            ========================= */
            group.position.set(position.x, position.y, position.z);
            scene.add(group);

            /* =========================
               Wave Animation
            ========================= */
            function animateFlag(time) {
                const pos = flag.geometry.attributes.position;

                for (let i = 0; i < pos.count; i++) {
                    const x = pos.getX(i);
                    pos.setZ(i, Math.sin(x * 2 + time * 0.005) * 0.2);
                }

                pos.needsUpdate = true;
            }

            return { group, animateFlag };
        }


        function createRoadGeometry(curve, width, segments) {
            const points = curve.getSpacedPoints(segments);
            const vertices = [];
            const uvs = [];
            const indices = [];

            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const p = points[i];
                const tangent = curve.getTangentAt(t).normalize();
                const binormal = new THREE.Vector3().crossVectors(tangent, new THREE.Vector3(0, 1, 0)).normalize();

                const pL = p.clone().add(binormal.clone().multiplyScalar(width / 2));
                const pR = p.clone().add(binormal.clone().multiplyScalar(-width / 2));

                vertices.push(pL.x, 0, pL.z, pR.x, 0, pR.z);

                const dist = t * curve.getLength();
                uvs.push(0, dist / 20, 1, dist / 20);

                if (i < segments) {
                    const idx = i * 2;
                    indices.push(idx, idx + 2, idx + 1, idx + 1, idx + 2, idx + 3);
                }
            }

            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geo.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            geo.setIndex(indices);
            geo.computeVertexNormals();
            return geo;
        }

        function createMarkingsTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 1024;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 512, 1024);
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 12;
            ctx.setLineDash([60, 60]);
            ctx.beginPath(); ctx.moveTo(256, 0); ctx.lineTo(256, 1024); ctx.stroke();
            ctx.setLineDash([]);
            ctx.globalAlpha = 0.6;
            ctx.lineWidth = 8;
            ctx.strokeRect(15, -10, 2, 1044);
            ctx.strokeRect(495, -10, 2, 1044);
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.anisotropy = 16;
            return texture;
        }


        /**
         * Creates a simple low-poly tree.
         */
        function createTree() {
            const treeGroup = new THREE.Group();

            // Trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.5, 6);
            const trunkMaterial = new THREE.MeshBasicMaterial({ color: 0x8D6E63 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 0.25;
            treeGroup.add(trunk);

            // Foliage
            const leavesMaterial = new THREE.MeshBasicMaterial({ color: 0x388E3C });
            const lowerCone = new THREE.Mesh(new THREE.ConeGeometry(0.3, 0.6, 8), leavesMaterial);
            lowerCone.position.y = 0.6;
            treeGroup.add(lowerCone);

            const upperCone = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.5, 8), leavesMaterial);
            upperCone.position.y = 0.9;
            treeGroup.add(upperCone);

            return treeGroup;
        }

        /**
         * Creates the new L-Wing house model from the provided CONFIG and logic.
         * Scaled down to fit the city proportions.
         */
        /**
         * Creates the new L-Wing house model including a stylish boundary wall and gate.
         */
        function createHouse(id, plotW = 500, plotD = 600, skipWall = null) {
            const CONFIG = {
                houseWidth: 220,
                houseDepth: 280,
                wingLen: 260,
                floorH: 100,
                wingW: 100,
                roofH: 80
            };

            const house = new THREE.Group();

            // Materials
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0xe8e4d9 });
            const roofMat = new THREE.MeshStandardMaterial({ color: 0xC47460 });
            const winMat = new THREE.MeshStandardMaterial({ color: 0xadd8e6, emissive: 0x111111 });
            const woodMat = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
            const beamMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const baseMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
            const wallMat = new THREE.MeshBasicMaterial({ color: 0xeeeeee });
            const gateMat = new THREE.MeshBasicMaterial({ color: 0x222222 }); // Dark stylish gate
            const glassMat = new THREE.MeshStandardMaterial({ color: 0x88ccff, transparent: true, opacity: 0.5 }); // New Glass Material

            const { houseWidth, houseDepth, wingLen, floorH, wingW, roofH } = CONFIG;

            // --- Full Land Boundary Wall & Stylish Gate ---
            const wallH = 30;
            const wallT = 8;
            const gateW = 100;

            // Back Wall
            const backWall = new THREE.Mesh(new THREE.BoxGeometry(plotW, wallH, wallT), wallMat);
            backWall.position.set(0, wallH / 2, plotD / 2 - wallT / 2);
            house.add(backWall);

            // Left Wall (Skip if requested to avoid "double wall")
            if (skipWall !== 'left') {
                const leftWall = new THREE.Mesh(new THREE.BoxGeometry(wallT, wallH, plotD), wallMat);
                leftWall.position.set(-plotW / 2 + wallT / 2, wallH / 2, 0);
                house.add(leftWall);
            }

            // Right Wall (Skip if requested to avoid "double wall")
            if (skipWall !== 'right') {
                const rightWall = new THREE.Mesh(new THREE.BoxGeometry(wallT, wallH, plotD), wallMat);
                rightWall.position.set(plotW / 2 - wallT / 2, wallH / 2, 0);
                house.add(rightWall);
            }

            // Front Wall with Stylish Gate
            const frontSegW = (plotW - gateW) / 2;
            const frontWallL = new THREE.Mesh(new THREE.BoxGeometry(frontSegW, wallH, wallT), wallMat);
            frontWallL.position.set(-plotW / 2 + frontSegW / 2, wallH / 2, -plotD / 2 + wallT / 2);
            house.add(frontWallL);

            const frontWallR = new THREE.Mesh(new THREE.BoxGeometry(frontSegW, wallH, wallT), wallMat);
            frontWallR.position.set(plotW / 2 - frontSegW / 2, wallH / 2, -plotD / 2 + wallT / 2);
            house.add(frontWallR);

            // --- Stylish Gate Pillars ---
            const pillarGeo = new THREE.BoxGeometry(15, wallH + 15, 15);
            const pLeft = new THREE.Mesh(pillarGeo, gateMat);
            pLeft.position.set(-gateW / 2, (wallH + 15) / 2, -plotD / 2 + wallT / 2);
            house.add(pLeft);

            const pRight = new THREE.Mesh(pillarGeo, gateMat);
            pRight.position.set(gateW / 2, (wallH + 15) / 2, -plotD / 2 + wallT / 2);
            house.add(pRight);

            // --- Gate Bars ---
            for (let i = 0; i < 5; i++) {
                const bar = new THREE.Mesh(new THREE.BoxGeometry(gateW, 3, 3), gateMat);
                bar.position.set(0, 5 + (i * 10), -plotD / 2 + wallT / 2);
                house.add(bar);
            }

            // --- Building Group for easy shifting ---
            const building = new THREE.Group();
            building.position.x = 200; // Move right side total 300px (100 + 200)
            house.add(building);

            // --- Building Components (Main Body, Wing, Roof, door, etc.) shifted back for front space ---
            const buildingOffsetZ = 120;

            // Main Structure
            const mainBody = new THREE.Mesh(new THREE.BoxGeometry(houseWidth, floorH * 2, houseDepth), bodyMat);
            mainBody.position.set(0, floorH, buildingOffsetZ);
            mainBody.castShadow = true;
            building.add(mainBody);

            // L-Wing Extension
            const wingBody = new THREE.Mesh(new THREE.BoxGeometry(wingLen, floorH * 2, wingW), bodyMat);
            wingBody.position.set(-(houseWidth / 2 + wingLen / 2), floorH, houseDepth / 2 - wingW / 2 + buildingOffsetZ);
            wingBody.castShadow = true;
            building.add(wingBody);

            // DOORS with IDs
            const doorCanvas = document.createElement('canvas');
            doorCanvas.width = 64; doorCanvas.height = 128;
            const dctx = doorCanvas.getContext('2d');
            dctx.fillStyle = '#8b4513'; dctx.fillRect(0, 0, 64, 128);
            dctx.fillStyle = '#FFFFFF'; dctx.font = 'bold 30px Arial';
            dctx.textAlign = 'center'; dctx.textBaseline = 'middle';
            dctx.fillText(id, 32, 40);
            const doorTex = new THREE.CanvasTexture(doorCanvas);

            const door = new THREE.Mesh(new THREE.BoxGeometry(45, 75, 5), new THREE.MeshStandardMaterial({ map: doorTex }));
            door.position.set(0, 37.5, -(houseDepth / 2 + 2) + buildingOffsetZ);
            building.add(door);

            // Balcony Doors
            const bDoor1 = door.clone(); bDoor1.position.set(-60, floorH + 37.5, -(houseDepth / 2 + 2) + buildingOffsetZ);
            const bDoor2 = door.clone(); bDoor2.position.set(60, floorH + 37.5, -(houseDepth / 2 + 2) + buildingOffsetZ);
            building.add(bDoor1); building.add(bDoor2);

            // Windows
            const winGeo = new THREE.PlaneGeometry(40, 50);
            [-(houseWidth / 2 + 80), -(houseWidth / 2 + 220)].forEach(x => {
                const w1 = new THREE.Mesh(winGeo, winMat);
                w1.position.set(x, 45, houseDepth / 2 - wingW - 1.5 + buildingOffsetZ);
                w1.rotation.y = Math.PI;
                building.add(w1);
                const w2 = w1.clone(); w2.position.y = floorH + 45;
                building.add(w2);
            });

            // --- PORCHES & BALCONIES ---
            // Main Porch (Ground)
            const porch = new THREE.Mesh(new THREE.BoxGeometry(houseWidth - 20, 10, 80), new THREE.MeshStandardMaterial({ color: 0xcccccc }));
            porch.position.set(0, 5, -(houseDepth / 2 + 40) + buildingOffsetZ);
            building.add(porch);

            // Main Balcony (1st Floor)
            const balcony = porch.clone(); balcony.position.y = floorH + 5;
            building.add(balcony);

            // Glass Railing for Main Balcony
            const railH = 35;
            const glassRail = new THREE.Mesh(new THREE.BoxGeometry(houseWidth - 20, railH, 2), glassMat);
            glassRail.position.set(0, floorH + 5 + railH / 2 + 5, -(houseDepth / 2 + 80) + buildingOffsetZ);
            building.add(glassRail);

            // Side glass railings for Main Balcony
            const mRailSideL = new THREE.Mesh(new THREE.BoxGeometry(2, railH, 80), glassMat);
            mRailSideL.position.set(-(houseWidth - 20) / 2, floorH + 5 + railH / 2 + 5, -(houseDepth / 2 + 40) + buildingOffsetZ);
            building.add(mRailSideL);

            const mRailSideR = new THREE.Mesh(new THREE.BoxGeometry(2, railH, 80), glassMat);
            mRailSideR.position.set((houseWidth - 20) / 2, floorH + 5 + railH / 2 + 5, -(houseDepth / 2 + 40) + buildingOffsetZ);
            building.add(mRailSideR);

            // Wing Balcony (1st Floor)
            const wingBalcony = new THREE.Mesh(new THREE.BoxGeometry(wingLen - 40, 10, 60), new THREE.MeshStandardMaterial({ color: 0xcccccc }));
            wingBalcony.position.set(-(houseWidth / 2 + wingLen / 2), floorH + 5, houseDepth / 2 - wingW - 30 + buildingOffsetZ);
            building.add(wingBalcony);

            // Glass Railing for Wing Balcony
            const wGlassRail = new THREE.Mesh(new THREE.BoxGeometry(wingLen - 40, railH, 2), glassMat);
            wGlassRail.position.set(-(houseWidth / 2 + wingLen / 2), floorH + 5 + railH / 2 + 5, houseDepth / 2 - wingW - 60 + buildingOffsetZ);
            building.add(wGlassRail);

            // Side glass railings for Wing Balcony
            const wRailSideL = new THREE.Mesh(new THREE.BoxGeometry(2, railH, 60), glassMat);
            wRailSideL.position.set(-(houseWidth / 2 + wingLen / 2) - (wingLen - 40) / 2, floorH + 5 + railH / 2 + 5, houseDepth / 2 - wingW - 30 + buildingOffsetZ);
            building.add(wRailSideL);

            const wRailSideR = new THREE.Mesh(new THREE.BoxGeometry(2, railH, 60), glassMat);
            wRailSideR.position.set(-(houseWidth / 2 + wingLen / 2) + (wingLen - 40) / 2, floorH + 5 + railH / 2 + 5, houseDepth / 2 - wingW - 30 + buildingOffsetZ);
            building.add(wRailSideR);

            // Wing Doors (1st & 2nd Level Access)
            const wDoor1 = door.clone();
            wDoor1.position.set(-(houseWidth / 2 + 80), floorH + 37.5, houseDepth / 2 - wingW - 2 + buildingOffsetZ);
            wDoor1.rotation.y = Math.PI;
            building.add(wDoor1);

            const wDoor2 = door.clone();
            wDoor2.position.set(-(houseWidth / 2 + 180), floorH + 37.5, houseDepth / 2 - wingW - 2 + buildingOffsetZ);
            wDoor2.rotation.y = Math.PI;
            building.add(wDoor2);

            // Roofs
            const mRoofS = new THREE.Shape();
            mRoofS.moveTo(-houseWidth / 2 - 20, 0); mRoofS.lineTo(0, roofH); mRoofS.lineTo(houseWidth / 2 + 20, 0);
            const mRoof = new THREE.Mesh(new THREE.ExtrudeGeometry(mRoofS, { depth: houseDepth + 40, bevelEnabled: false }), roofMat);
            mRoof.position.set(0, floorH * 2, -houseDepth / 2 - 20 + buildingOffsetZ);
            building.add(mRoof);

            const wRoofS = new THREE.Shape();
            wRoofS.moveTo(-wingW / 2 - 20, 0); wRoofS.lineTo(0, roofH); wRoofS.lineTo(wingW / 2 + 20, 0);
            const wRoof = new THREE.Mesh(new THREE.ExtrudeGeometry(wRoofS, { depth: wingLen + 130, bevelEnabled: false }), roofMat);
            wRoof.rotation.y = -Math.PI / 2;
            // Align precisely with the wing body center and move it further INTO the main body to fill the gap
            const wingCenterZ = houseDepth / 2 - wingW / 2 + buildingOffsetZ;
            wRoof.position.set(-(houseWidth / 2 - 112), floorH * 2, wingCenterZ);
            building.add(wRoof);

            // Beams
            const beamGeo = new THREE.CylinderGeometry(5, 5, floorH);
            const b1 = new THREE.Mesh(beamGeo, beamMat);
            b1.position.set(-(houseWidth / 2 - 30), floorH / 2, -(houseDepth / 2 + 60) + buildingOffsetZ);
            building.add(b1);
            const b2 = b1.clone(); b2.position.x = houseWidth / 2 - 30;
            building.add(b2);

            const scale = 0.015;
            house.scale.set(scale, scale, scale);

            return house;
        }

        class RiverSystem {
            constructor(scene, points, options = {}) {
                this.scene = scene;
                this.points = points;
                this.color = new THREE.Color(options.color || 0x0077ff);
                this.width = options.width || 4.5;
                this.thickness = options.thickness || 0.1;
                this.pos = options.position || { x: 0, y: 0, z: 0 };
                this.rot = options.rotation || { x: 0, y: 0, z: 0 };

                this.shaderMaterial = null;
                this.mesh = null;
                this.edgeMesh = null;

                this._init();
            }

            _init() {
                // High-quality centripetal curve for smooth turns
                const curve = new THREE.CatmullRomCurve3(this.points, false, 'centripetal');
                const tubeGeometry = new THREE.TubeGeometry(curve, 512, this.width, 16, false);

                const vertexShader = `
                    varying vec2 vUv;
                    uniform float uTime;
                    void main() {
                        vUv = uv;
                        vec3 pos = position;
                        // Animated water vertical movement
                        float wave = sin(pos.x * 0.15 + uTime * 2.5) * 0.4;
                        pos.y += wave;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    }
                `;

                const fragmentShader = `
                    uniform vec3 uColor;
                    uniform float uTime;
                    varying vec2 vUv;
                    void main() {
                        // High-quality scrolling ripples from the image
                        float ripple = sin((vUv.x * 20.0) - (uTime * 2.5)) * 0.5 + 0.5;
                        
                        // Center-to-edge glow like the reference image
                        float centerDist = abs(vUv.y - 0.5) * 2.0; 
                        float highlight = pow(1.0 - centerDist, 4.0);
                        
                        vec3 baseColor = mix(uColor * 0.6, uColor + vec3(0.2, 0.4, 0.6), highlight);
                        baseColor += ripple * 0.15 * highlight; 
                        
                        gl_FragColor = vec4(baseColor, 1.0); // Full opacity for city visibility
                    }
                `;

                this.shaderMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        uTime: { value: 0 },
                        uColor: { value: this.color }
                    },
                    vertexShader: vertexShader,
                    fragmentShader: fragmentShader,
                    transparent: false // Make it solid for better visibility
                });

                this.mesh = new THREE.Mesh(tubeGeometry, this.shaderMaterial);
                this.mesh.scale.set(1, this.thickness, 1);
                this.mesh.position.set(this.pos.x, this.pos.y, this.pos.z);
                this.mesh.rotation.set(this.rot.x, this.rot.y, this.rot.z);

                this.scene.add(this.mesh);
            }

            update(time) {
                if (this.shaderMaterial && this.shaderMaterial.uniforms) {
                    this.shaderMaterial.uniforms.uTime.value = time;
                }
            }

            dispose() {
                this.scene.remove(this.mesh);
                if (this.edgeMesh) this.scene.remove(this.edgeMesh);
                this.mesh.geometry.dispose();
                this.shaderMaterial.dispose();
            }
        }


        /**
         * Creates a bunch of houses organized in two serial blocks (Odd & Even).
         * Each serial comes in a pair (A & B).
         */
        function createHouseBunch(parent, options) {
            const houseScale = 0.015;
            const {
                serialCount = 10,
                startX = 0,
                startZ = 0,
                plotWidth = 900, // Pre-scaled dimension
                plotDepth = 1200, // Pre-scaled dimension
                unitSpacing = (plotWidth * houseScale),
                rowSpacing = plotDepth * houseScale,
                houseGap = unitSpacing * 0.35,
                // New Padding and Thickness defaults
                paddingLeft = 2,
                paddingRight = 2,
                paddingTop = 2,
                paddingBottom = 2,
                landThickness = 3.5,
                startId = 1,
                clusterName = "CLUSTER-6"
            } = options;

            const bunchGroup = new THREE.Group();
            bunchGroup.position.set(startX, 0, startZ);
            parent.add(bunchGroup);

            // Calculate Bunch Land Size including padding
            const totalUnits = Math.ceil(serialCount / 2);
            const landWidth = totalUnits * unitSpacing + paddingLeft + paddingRight;
            const landDepth = (2 * rowSpacing) + paddingTop + paddingBottom;

            // Create Bunch Land Area as a 3D Box
            const landGeo = new THREE.BoxGeometry(landWidth, landThickness, landDepth);
            const landMat = new THREE.MeshBasicMaterial({
                color: 0xA9DA3F,
                // color: 0xc1d86c,
                polygonOffset: true,
                polygonOffsetFactor: 3,
                polygonOffsetUnits: 3
            });
            const landMesh = new THREE.Mesh(landGeo, landMat);

            // Positioning the land box
            const centerX = ((totalUnits - 1) * unitSpacing) / 2 + (paddingRight - paddingLeft) / 2;
            const centerZ = (rowSpacing / 2) + (paddingBottom - paddingTop) / 2;
            landMesh.position.set(centerX, -landThickness / 2 + 0.01, centerZ);
            bunchGroup.add(landMesh);

            const oddRow = new THREE.Group();
            const evenRow = new THREE.Group();
            evenRow.position.z = rowSpacing;

            bunchGroup.add(oddRow);
            bunchGroup.add(evenRow);

            // Add Cluster Label in the middle
            if (clusterName) {
                const labelCanvas = document.createElement('canvas');
                labelCanvas.width = 512; labelCanvas.height = 128;
                const lctx = labelCanvas.getContext('2d');
                lctx.fillStyle = 'rgba(255, 255, 0, 0.8)'; // Yellow background
                lctx.fillRect(0, 0, 512, 128);
                lctx.fillStyle = '#000000';
                lctx.font = 'bold 80px Arial';
                lctx.textAlign = 'center'; lctx.textBaseline = 'middle';
                lctx.fillText(clusterName, 256, 64);

                const labelTex = new THREE.CanvasTexture(labelCanvas);
                const labelGeo = new THREE.PlaneGeometry(6, 1.5);
                const labelMat = new THREE.MeshBasicMaterial({ map: labelTex, transparent: true });
                const label = new THREE.Mesh(labelGeo, labelMat);
                label.rotation.x = -Math.PI / 2;
                label.position.set(((totalUnits - 1) * unitSpacing) / 2, 0.05, rowSpacing / 2);
                bunchGroup.add(label);
            }

            for (let i = 0; i < serialCount; i++) {
                const serialNum = startId + i;
                const formattedId = "H-" + serialNum.toString().padStart(2, '0');
                const unitGroup = new THREE.Group();

                // Position the unit in two rows (Odd/Even)
                const localIdx = Math.floor(i / 2);
                unitGroup.position.x = localIdx * unitSpacing;

                // Create Single House
                const house = createHouse(formattedId, plotWidth, plotDepth);
                unitGroup.add(house);

                if (serialNum % 2 !== 0) {
                    unitGroup.rotation.y = Math.PI; // Face the opposite direction
                    oddRow.add(unitGroup);
                } else {
                    evenRow.add(unitGroup);
                }

                // Add tree at the front side of the house area
                const tree = createTree();
                // Front side of row. 
                const treeZ = (serialNum % 2 !== 0) ? -rowSpacing * 0.4 : rowSpacing + rowSpacing * 0.4;
                tree.position.set(unitGroup.position.x + 2.5, 0, treeZ);
                bunchGroup.add(tree);
            }

            return bunchGroup;
        }
        function createHouseCluster(parent, options) {
            const houseScale = 0.015;
            const {
                serialCount = 10,
                startX = 0,
                startZ = 0,
                plotWidth = 900, // Pre-scaled dimension
                plotDepth = 1000, // Pre-scaled dimension
                unitSpacing = (plotWidth * houseScale),
                rowSpacing = plotDepth * houseScale,
                houseGap = unitSpacing * 0.35,
                // New Padding and Thickness defaults
                paddingLeft = 2,
                paddingRight = 2,
                paddingTop = 2,
                paddingBottom = 2,
                landThickness = 3.5,
                startId = 1,
                clusterName = "CLUSTER-6"
            } = options;

            const clusterGroup = new THREE.Group();
            clusterGroup.position.set(startX, 0, startZ);
            parent.add(clusterGroup);

            // Calculate Bunch Land Size including padding
            const totalUnits = Math.ceil(serialCount / 2);
            const landWidth = totalUnits * unitSpacing + paddingLeft + paddingRight;
            const landDepth = (2 * rowSpacing) + paddingTop + paddingBottom;

            // Create Bunch Land Area as a 3D Box
            const landGeo = new THREE.BoxGeometry(landWidth, landThickness, landDepth);
            const landMat = new THREE.MeshBasicMaterial({
                color: 0xA9DA3F,
                // color: 0xc1d86c,
                polygonOffset: true,
                polygonOffsetFactor: 3,
                polygonOffsetUnits: 3
            });
            const landMesh = new THREE.Mesh(landGeo, landMat);

            // Positioning the land box
            const centerX = ((totalUnits - 1) * unitSpacing) / 2 + (paddingRight - paddingLeft) / 2;
            const centerZ = (rowSpacing / 2) + (paddingBottom - paddingTop) / 2;
            landMesh.position.set(centerX, -landThickness / 2 + 0.01, centerZ);
            clusterGroup.add(landMesh);

            const oddRow = new THREE.Group();
            const evenRow = new THREE.Group();
            evenRow.position.z = rowSpacing;

            clusterGroup.add(oddRow);
            clusterGroup.add(evenRow);

            // Add Cluster Label in the middle
            if (clusterName) {
                const labelCanvas = document.createElement('canvas');
                labelCanvas.width = 512; labelCanvas.height = 128;
                const lctx = labelCanvas.getContext('2d');
                lctx.fillStyle = 'rgba(255, 255, 0, 0.8)'; // Yellow background
                lctx.fillRect(0, 0, 512, 128);
                lctx.fillStyle = '#000000';
                lctx.font = 'bold 80px Arial';
                lctx.textAlign = 'center'; lctx.textBaseline = 'middle';
                lctx.fillText(clusterName, 256, 64);

                const labelTex = new THREE.CanvasTexture(labelCanvas);
                const labelGeo = new THREE.PlaneGeometry(6, 1.5);
                const labelMat = new THREE.MeshBasicMaterial({ map: labelTex, transparent: true });
                const label = new THREE.Mesh(labelGeo, labelMat);
                label.rotation.x = -Math.PI / 2;
                label.position.set(((totalUnits - 1) * unitSpacing) / 2, 0.05, rowSpacing / 2);
                clusterGroup.add(label);
            }

            for (let i = 0; i < serialCount; i++) {
                const serialNum = startId + i;
                const formattedId = "H-" + serialNum.toString().padStart(2, '0');
                const unitGroup = new THREE.Group();

                // Position the unit in two rows (Odd/Even)
                const localIdx = Math.floor(i / 2);
                unitGroup.position.x = localIdx * unitSpacing;

                // Create Single House
                const house = createHouse(formattedId, plotWidth, plotDepth);
                unitGroup.add(house);

                if (serialNum % 2 !== 0) {
                    unitGroup.rotation.y = Math.PI; // Face the opposite direction
                    oddRow.add(unitGroup);
                } else {
                    evenRow.add(unitGroup);
                }

                // Add tree at the front side of the house area
                const tree = createTree();
                // Front side of row. 
                const treeZ = (serialNum % 2 !== 0) ? -rowSpacing * 0.4 : rowSpacing + rowSpacing * 0.4;
                tree.position.set(unitGroup.position.x + 2.5, 0, treeZ);
                clusterGroup.add(tree);
            }

            return clusterGroup;
        }

        window.onload = init
    </script>


</body>

</html>