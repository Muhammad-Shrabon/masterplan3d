<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Seamless Road City System</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', sans-serif;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 12px;
            pointer-events: none;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }
    </style>
</head>

<body>
    <div id="ui">
        <h3 style="margin:0">City Road System</h3>
        <p style="font-size: 0.85em; opacity: 0.7;">Use Mouse to Orbit, Scroll to Zoom, Right-Click to Pan.</p>
    </div>

    <script>
        let scene, camera, renderer, clock, controls;

        // Configuration
        const ROAD_CONFIGS = [
            {
                width: 12,
                points: [
                    new THREE.Vector3(0, 0, 100),
                    new THREE.Vector3(0, 0, -200),
                    new THREE.Vector3(50, 0, -400),
                    new THREE.Vector3(200, 0, -600)
                ],
                segments: 200
            },
            {
                width: 10,
                points: [
                    new THREE.Vector3(0, 0, -50),
                    new THREE.Vector3(-100, 0, -100),
                    new THREE.Vector3(-250, 0, -150),
                    new THREE.Vector3(-400, 0, -400),
                    new THREE.Vector3(-1200, 0, -1200),
                    new THREE.Vector3(-600, 0, -600),
                ],
                segments: 200
            }
        ];

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.FogExp2(0x87ceeb, 0.0005);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
            camera.position.set(100, 100, 300);
            clock = new THREE.Clock();

            renderer = new THREE.WebGLRenderer({
                antialias: true,
                logarithmicDepthBuffer: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Orbit Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const sun = new THREE.DirectionalLight(0xffffff, 1.0);
            sun.position.set(200, 400, 200);
            sun.castShadow = true;
            sun.shadow.camera.left = -1000; sun.shadow.camera.right = 1000;
            sun.shadow.camera.top = 1000; sun.shadow.camera.bottom = -1000;
            sun.shadow.mapSize.set(2048, 2048);
            scene.add(sun);

            // Ground
            const groundGeo = new THREE.PlaneGeometry(10000, 10000);
            const groundMat = new THREE.MeshStandardMaterial({
                color: 0x3d5a2b,
                polygonOffset: true,
                polygonOffsetFactor: 4,
                polygonOffsetUnits: 4
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.05; // Slightly below zero
            ground.receiveShadow = true;
            scene.add(ground);

            const asphaltBaseMat = new THREE.MeshStandardMaterial({
                color: 0x222222,
                roughness: 0.9,
                polygonOffset: true,
                polygonOffsetFactor: 2,
                polygonOffsetUnits: 2
            });

            const markingsMat = new THREE.MeshStandardMaterial({
                map: createMarkingsTexture(),
                transparent: true,
                depthWrite: false,
                blending: THREE.NormalBlending,
                polygonOffset: true,
                polygonOffsetFactor: -1,
                polygonOffsetUnits: -1
            });

            ROAD_CONFIGS.forEach(config => {
                const curve = new THREE.CatmullRomCurve3(config.points);
                const roadGeo = createRoadGeometry(curve, config.width, config.segments);

                const baseMesh = new THREE.Mesh(roadGeo, asphaltBaseMat);
                baseMesh.receiveShadow = true;
                scene.add(baseMesh);

                const markingsMesh = new THREE.Mesh(roadGeo, markingsMat);
                markingsMesh.position.y = 0.01;
                scene.add(markingsMesh);

                createCityBuildings(curve, config.width);
            });

            animate();
        }

        function createRoadGeometry(curve, width, segments) {
            const points = curve.getSpacedPoints(segments);
            const vertices = [];
            const uvs = [];
            const indices = [];

            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const p = points[i];
                const tangent = curve.getTangentAt(t).normalize();
                const binormal = new THREE.Vector3().crossVectors(tangent, new THREE.Vector3(0, 1, 0)).normalize();

                const pL = p.clone().add(binormal.clone().multiplyScalar(width / 2));
                const pR = p.clone().add(binormal.clone().multiplyScalar(-width / 2));

                vertices.push(pL.x, 0, pL.z, pR.x, 0, pR.z);

                const dist = t * curve.getLength();
                uvs.push(0, dist / 20, 1, dist / 20);

                if (i < segments) {
                    const idx = i * 2;
                    indices.push(idx, idx + 2, idx + 1, idx + 1, idx + 2, idx + 3);
                }
            }

            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geo.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            geo.setIndex(indices);
            geo.computeVertexNormals();
            return geo;
        }

        function createMarkingsTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 1024;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 512, 1024);
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 12;
            ctx.setLineDash([60, 60]);
            ctx.beginPath(); ctx.moveTo(256, 0); ctx.lineTo(256, 1024); ctx.stroke();
            ctx.setLineDash([]);
            ctx.globalAlpha = 0.6;
            ctx.lineWidth = 8;
            ctx.strokeRect(15, -10, 2, 1044);
            ctx.strokeRect(495, -10, 2, 1044);
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.anisotropy = 16;
            return texture;
        }

         
        function createCityBuildings(curve, roadWidth) {
            const length = curve.getLength();
            const count = Math.floor(length / 40);

            for (let i = 0; i < count; i++) {
                const t = i / count;
                const p = curve.getPointAt(t);
                const tangent = curve.getTangentAt(t).normalize();
                const binormal = new THREE.Vector3().crossVectors(tangent, new THREE.Vector3(0, 1, 0)).normalize();

                // Left and right side of road
                [1, -1].forEach(side => {
                    const offset = roadWidth * 1.5;
                    const buildingPos = p.clone().add(binormal.clone().multiplyScalar(side * offset));

                    const building = createBuilding();
                    building.position.copy(buildingPos);

                    // Rotate to face road
                    const lookAtTarget = p.clone();
                    building.lookAt(lookAtTarget);

                    scene.add(building);

                    // Add a tree next to building
                    const treePos = buildingPos.clone().add(tangent.clone().multiplyScalar(10));
                    const tree = createTree();
                    tree.position.copy(treePos);
                    scene.add(tree);
                });
            }
        }

        function createBuilding() {
            const group = new THREE.Group();

            const heights = [15, 25, 40, 60];
            const h = heights[Math.floor(Math.random() * heights.length)];
            const w = 15 + Math.random() * 5;
            const d = 15 + Math.random() * 5;

            const color = new THREE.Color().setHSL(Math.random(), 0.2, 0.4);
            const mat = new THREE.MeshStandardMaterial({ color: color });
            const geo = new THREE.BoxGeometry(w, h, d);
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.y = h / 2;
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            group.add(mesh);

            // Windows
            const winMat = new THREE.MeshStandardMaterial({ color: 0xffffaa, emissive: 0xffffaa, emissiveIntensity: 0.5 });
            const rows = Math.floor(h / 3);
            const cols = Math.floor(w / 3);
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    if (Math.random() > 0.3) {
                        const winGeo = new THREE.PlaneGeometry(1.5, 1.5);
                        const win = new THREE.Mesh(winGeo, winMat);
                        win.position.set(-w / 2 + c * 3 + 1.5, h / 2 - r * 3 - 1.5, d / 2 + 0.1);
                        group.add(win);
                    }
                }
            }

            return group;
        }

        function createTree() {
            const group = new THREE.Group();
            const trunkGeo = new THREE.CylinderGeometry(0.5, 0.7, 4, 8);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x4b3621 });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = 2;
            group.add(trunk);

            const foliageGeo = new THREE.ConeGeometry(5, 10, 8);
            const foliageMat = new THREE.MeshStandardMaterial({ color: 0x2d5a27 });
            const foliage = new THREE.Mesh(foliageGeo, foliageMat);
            foliage.position.y = 8;
            group.add(foliage);

            group.traverse(o => { if (o.isMesh) { o.castShadow = true; o.receiveShadow = true; } });
            return group;
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>

</html>