<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Seamless Road Junction System</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        #ui {
            position: absolute;
            top: 20px; left: 20px; color: white;
            background: rgba(0,0,0,0.8); padding: 20px; border-radius: 12px;
            pointer-events: none; border: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
        }
    </style>
</head>
<body>
    <div id="ui">
        <h3 style="margin:0">Advanced Junction Logic</h3>
        <p style="font-size: 0.85em; opacity: 0.7;">Using Unified Base Layer + Decal Markings to solve Z-fighting.</p>
    </div>

    <script>
        let scene, camera, renderer, clock;
        let character, walkCycle = 0, isWalking = false;
        let leftLeg, rightLeg, leftArm, rightArm;

        // Configuration
        const ROAD_CONFIGS = [
            {
                width: 12,
                points: [
                    new THREE.Vector3(0, 0, 100),
                    new THREE.Vector3(0, 0, -200),
                    new THREE.Vector3(50, 0, -400),
                    new THREE.Vector3(200, 0, -600)
                ],
                segments: 200
            },
            {
                width: 10,
                points: [
                    new THREE.Vector3(0, 0, -50), 
                    new THREE.Vector3(-100, 0, -100),
                    new THREE.Vector3(-250, 0, -150),
                    new THREE.Vector3(-400, 0, -400)
                ],
                segments: 200
            }
        ];

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.FogExp2(0x87ceeb, 0.001);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 5000);
            clock = new THREE.Clock();

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const sun = new THREE.DirectionalLight(0xffffff, 1.0);
            sun.position.set(200, 400, 200);
            sun.castShadow = true;
            sun.shadow.camera.left = -1000; sun.shadow.camera.right = 1000;
            sun.shadow.camera.top = 1000; sun.shadow.camera.bottom = -1000;
            sun.shadow.mapSize.set(2048, 2048);
            scene.add(sun);

            // 1. SHARED ASPHALT BASE (No texture, just color)
            // We use the same material for all road bases so overlapping doesn't flicker
            const asphaltBaseMat = new THREE.MeshStandardMaterial({ 
                color: 0x222222, 
                roughness: 0.9 
            });

            // 2. MARKINGS MATERIAL (Transparent with blending)
            const markingsMat = new THREE.MeshStandardMaterial({
                map: createMarkingsTexture(),
                transparent: true,
                depthWrite: false, // This is key: markings don't block each other's depth
                blending: THREE.NormalBlending,
                polygonOffset: true,
                polygonOffsetFactor: -1, // Push slightly forward
                polygonOffsetUnits: -1
            });

            ROAD_CONFIGS.forEach(config => {
                const curve = new THREE.CatmullRomCurve3(config.points);
                const roadGeo = createRoadGeometry(curve, config.width, config.segments);
                
                // Create the base mesh
                const baseMesh = new THREE.Mesh(roadGeo, asphaltBaseMat);
                baseMesh.receiveShadow = true;
                scene.add(baseMesh);

                // Create the markings mesh (slightly higher)
                const markingsMesh = new THREE.Mesh(roadGeo, markingsMat);
                markingsMesh.position.y = 0.01; 
                scene.add(markingsMesh);
            });

            createCharacter();
            setupControls();
            animate();
        }

        function createRoadGeometry(curve, width, segments) {
            const points = curve.getSpacedPoints(segments);
            const vertices = [];
            const uvs = [];
            const indices = [];

            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const p = points[i];
                const tangent = curve.getTangentAt(t).normalize();
                const binormal = new THREE.Vector3().crossVectors(tangent, new THREE.Vector3(0, 1, 0)).normalize();

                const pL = p.clone().add(binormal.clone().multiplyScalar(width / 2));
                const pR = p.clone().add(binormal.clone().multiplyScalar(-width / 2));

                vertices.push(pL.x, 0, pL.z, pR.x, 0, pR.z);
                
                const dist = t * curve.getLength();
                uvs.push(0, dist / 20, 1, dist / 20);

                if (i < segments) {
                    const idx = i * 2;
                    indices.push(idx, idx + 2, idx + 1, idx + 1, idx + 2, idx + 3);
                }
            }

            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geo.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            geo.setIndex(indices);
            geo.computeVertexNormals();
            return geo;
        }

        function createMarkingsTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 1024;
            const ctx = canvas.getContext('2d');
            
            // Clear to transparent
            ctx.clearRect(0, 0, 512, 1024);

            // Center dashes
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 12;
            ctx.setLineDash([60, 60]);
            ctx.beginPath(); ctx.moveTo(256, 0); ctx.lineTo(256, 1024); ctx.stroke();
            
            // Solid sides
            ctx.setLineDash([]);
            ctx.globalAlpha = 0.6;
            ctx.lineWidth = 8;
            ctx.strokeRect(15, -10, 2, 1044);
            ctx.strokeRect(495, -10, 2, 1044);

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.anisotropy = 16;
            return texture;
        }

        function createCharacter() {
            character = new THREE.Group();
            const mat = (c) => new THREE.MeshStandardMaterial({ color: c });
            const torso = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.9, 0.4), mat(0x2244aa));
            torso.position.y = 1.35;
            character.add(torso);
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), mat(0xffdbac));
            head.position.y = 2.05;
            character.add(head);
            const legGeo = new THREE.BoxGeometry(0.25, 0.9, 0.25);
            leftLeg = new THREE.Mesh(legGeo, mat(0x111111));
            leftLeg.position.set(-0.2, 0.45, 0);
            character.add(leftLeg);
            rightLeg = new THREE.Mesh(legGeo, mat(0x111111));
            rightLeg.position.set(0.2, 0.45, 0);
            character.add(rightLeg);
            const armGeo = new THREE.BoxGeometry(0.2, 0.8, 0.2);
            leftArm = new THREE.Mesh(armGeo, mat(0xffdbac));
            leftArm.position.set(-0.45, 1.3, 0);
            character.add(leftArm);
            rightArm = new THREE.Mesh(armGeo, mat(0xffdbac));
            rightArm.position.set(0.45, 1.3, 0);
            character.add(rightArm);
            character.traverse(c => { if(c.isMesh) c.castShadow = true; });
            character.position.set(0, 0, 50);
            scene.add(character);
        }

        function setupControls() {
            window.addEventListener('mousedown', () => isWalking = true);
            window.addEventListener('mouseup', () => isWalking = false);
            window.addEventListener('mousemove', (e) => {
                const rot = ((e.clientX / window.innerWidth) - 0.5) * Math.PI * 2;
                character.rotation.y = -rot;
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            if (isWalking) {
                const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(character.quaternion);
                character.position.add(dir.multiplyScalar(0.4));
                walkCycle += dt * 10;
                leftLeg.rotation.x = Math.sin(walkCycle) * 0.6;
                rightLeg.rotation.x = -Math.sin(walkCycle) * 0.6;
                leftArm.rotation.x = -Math.sin(walkCycle) * 0.6;
                rightArm.rotation.x = Math.sin(walkCycle) * 0.6;
                character.children[0].position.y = 1.35 + Math.abs(Math.cos(walkCycle)) * 0.05;
            } else {
                [leftLeg, rightLeg, leftArm, rightArm].forEach(p => p.rotation.x = THREE.MathUtils.lerp(p.rotation.x, 0, 0.1));
            }
            const offset = new THREE.Vector3(0, 6, 15).applyMatrix4(character.matrixWorld);
            camera.position.lerp(offset, 0.1);
            camera.lookAt(character.position.x, character.position.y + 1, character.position.z);
            renderer.render(scene, camera);
        }
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        init();
    </script>
</body>
</html>